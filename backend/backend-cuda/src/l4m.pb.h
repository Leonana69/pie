// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: l4m.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_l4m_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_l4m_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3021000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_l4m_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_l4m_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_l4m_2eproto;
namespace l4m {
class Allocate;
struct AllocateDefaultTypeInternal;
extern AllocateDefaultTypeInternal _Allocate_default_instance_;
class BatchAllocate;
struct BatchAllocateDefaultTypeInternal;
extern BatchAllocateDefaultTypeInternal _BatchAllocate_default_instance_;
class BatchCopyBlock;
struct BatchCopyBlockDefaultTypeInternal;
extern BatchCopyBlockDefaultTypeInternal _BatchCopyBlock_default_instance_;
class BatchDeallocate;
struct BatchDeallocateDefaultTypeInternal;
extern BatchDeallocateDefaultTypeInternal _BatchDeallocate_default_instance_;
class BatchDecodeTokenDistribution;
struct BatchDecodeTokenDistributionDefaultTypeInternal;
extern BatchDecodeTokenDistributionDefaultTypeInternal _BatchDecodeTokenDistribution_default_instance_;
class BatchEmbedText;
struct BatchEmbedTextDefaultTypeInternal;
extern BatchEmbedTextDefaultTypeInternal _BatchEmbedText_default_instance_;
class BatchFillBlock;
struct BatchFillBlockDefaultTypeInternal;
extern BatchFillBlockDefaultTypeInternal _BatchFillBlock_default_instance_;
class BatchMaskBlock;
struct BatchMaskBlockDefaultTypeInternal;
extern BatchMaskBlockDefaultTypeInternal _BatchMaskBlock_default_instance_;
class BatchSampleTopKRequest;
struct BatchSampleTopKRequestDefaultTypeInternal;
extern BatchSampleTopKRequestDefaultTypeInternal _BatchSampleTopKRequest_default_instance_;
class BatchSampleTopKResponse;
struct BatchSampleTopKResponseDefaultTypeInternal;
extern BatchSampleTopKResponseDefaultTypeInternal _BatchSampleTopKResponse_default_instance_;
class CopyBlock;
struct CopyBlockDefaultTypeInternal;
extern CopyBlockDefaultTypeInternal _CopyBlock_default_instance_;
class Deallocate;
struct DeallocateDefaultTypeInternal;
extern DeallocateDefaultTypeInternal _Deallocate_default_instance_;
class DecodeTokenDistribution;
struct DecodeTokenDistributionDefaultTypeInternal;
extern DecodeTokenDistributionDefaultTypeInternal _DecodeTokenDistribution_default_instance_;
class EmbedText;
struct EmbedTextDefaultTypeInternal;
extern EmbedTextDefaultTypeInternal _EmbedText_default_instance_;
class FillBlock;
struct FillBlockDefaultTypeInternal;
extern FillBlockDefaultTypeInternal _FillBlock_default_instance_;
class GetInfoRequest;
struct GetInfoRequestDefaultTypeInternal;
extern GetInfoRequestDefaultTypeInternal _GetInfoRequest_default_instance_;
class GetInfoResponse;
struct GetInfoResponseDefaultTypeInternal;
extern GetInfoResponseDefaultTypeInternal _GetInfoResponse_default_instance_;
class MaskBlock;
struct MaskBlockDefaultTypeInternal;
extern MaskBlockDefaultTypeInternal _MaskBlock_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SampleTopKRequest;
struct SampleTopKRequestDefaultTypeInternal;
extern SampleTopKRequestDefaultTypeInternal _SampleTopKRequest_default_instance_;
class SampleTopKResponse;
struct SampleTopKResponseDefaultTypeInternal;
extern SampleTopKResponseDefaultTypeInternal _SampleTopKResponse_default_instance_;
}  // namespace l4m
PROTOBUF_NAMESPACE_OPEN
template <>
::l4m::Allocate* Arena::CreateMaybeMessage<::l4m::Allocate>(Arena*);
template <>
::l4m::BatchAllocate* Arena::CreateMaybeMessage<::l4m::BatchAllocate>(Arena*);
template <>
::l4m::BatchCopyBlock* Arena::CreateMaybeMessage<::l4m::BatchCopyBlock>(Arena*);
template <>
::l4m::BatchDeallocate* Arena::CreateMaybeMessage<::l4m::BatchDeallocate>(Arena*);
template <>
::l4m::BatchDecodeTokenDistribution* Arena::CreateMaybeMessage<::l4m::BatchDecodeTokenDistribution>(Arena*);
template <>
::l4m::BatchEmbedText* Arena::CreateMaybeMessage<::l4m::BatchEmbedText>(Arena*);
template <>
::l4m::BatchFillBlock* Arena::CreateMaybeMessage<::l4m::BatchFillBlock>(Arena*);
template <>
::l4m::BatchMaskBlock* Arena::CreateMaybeMessage<::l4m::BatchMaskBlock>(Arena*);
template <>
::l4m::BatchSampleTopKRequest* Arena::CreateMaybeMessage<::l4m::BatchSampleTopKRequest>(Arena*);
template <>
::l4m::BatchSampleTopKResponse* Arena::CreateMaybeMessage<::l4m::BatchSampleTopKResponse>(Arena*);
template <>
::l4m::CopyBlock* Arena::CreateMaybeMessage<::l4m::CopyBlock>(Arena*);
template <>
::l4m::Deallocate* Arena::CreateMaybeMessage<::l4m::Deallocate>(Arena*);
template <>
::l4m::DecodeTokenDistribution* Arena::CreateMaybeMessage<::l4m::DecodeTokenDistribution>(Arena*);
template <>
::l4m::EmbedText* Arena::CreateMaybeMessage<::l4m::EmbedText>(Arena*);
template <>
::l4m::FillBlock* Arena::CreateMaybeMessage<::l4m::FillBlock>(Arena*);
template <>
::l4m::GetInfoRequest* Arena::CreateMaybeMessage<::l4m::GetInfoRequest>(Arena*);
template <>
::l4m::GetInfoResponse* Arena::CreateMaybeMessage<::l4m::GetInfoResponse>(Arena*);
template <>
::l4m::MaskBlock* Arena::CreateMaybeMessage<::l4m::MaskBlock>(Arena*);
template <>
::l4m::Request* Arena::CreateMaybeMessage<::l4m::Request>(Arena*);
template <>
::l4m::Response* Arena::CreateMaybeMessage<::l4m::Response>(Arena*);
template <>
::l4m::SampleTopKRequest* Arena::CreateMaybeMessage<::l4m::SampleTopKRequest>(Arena*);
template <>
::l4m::SampleTopKResponse* Arena::CreateMaybeMessage<::l4m::SampleTopKResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace l4m {
enum ObjectKind : int {
  OBJECT_KIND_UNSPECIFIED = 0,
  OBJECT_KIND_KV_BLOCK = 1,
  OBJECT_KIND_EMB = 2,
  OBJECT_KIND_DIST = 3,
  ObjectKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ObjectKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ObjectKind_IsValid(int value);
constexpr ObjectKind ObjectKind_MIN = static_cast<ObjectKind>(0);
constexpr ObjectKind ObjectKind_MAX = static_cast<ObjectKind>(3);
constexpr int ObjectKind_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ObjectKind_descriptor();
template <typename T>
const std::string& ObjectKind_Name(T value) {
  static_assert(std::is_same<T, ObjectKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ObjectKind_Name().");
  return ObjectKind_Name(static_cast<ObjectKind>(value));
}
template <>
inline const std::string& ObjectKind_Name(ObjectKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ObjectKind_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ObjectKind_Parse(absl::string_view name, ObjectKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectKind>(
      ObjectKind_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Allocate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.Allocate) */ {
 public:
  inline Allocate() : Allocate(nullptr) {}
  ~Allocate() override;
  explicit PROTOBUF_CONSTEXPR Allocate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Allocate(const Allocate& from);
  Allocate(Allocate&& from) noexcept
    : Allocate() {
    *this = ::std::move(from);
  }

  inline Allocate& operator=(const Allocate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Allocate& operator=(Allocate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Allocate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Allocate* internal_default_instance() {
    return reinterpret_cast<const Allocate*>(
               &_Allocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Allocate& a, Allocate& b) {
    a.Swap(&b);
  }
  inline void Swap(Allocate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Allocate* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Allocate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Allocate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Allocate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Allocate& from) {
    Allocate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Allocate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.Allocate";
  }
  protected:
  explicit Allocate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kObjectIdOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .l4m.ObjectKind kind = 1;
  void clear_kind() ;
  ::l4m::ObjectKind kind() const;
  void set_kind(::l4m::ObjectKind value);
  private:
  ::l4m::ObjectKind _internal_kind() const;
  void _internal_set_kind(::l4m::ObjectKind value);
  public:
  // uint32 object_id_offset = 2;
  void clear_object_id_offset() ;
  ::uint32_t object_id_offset() const;
  void set_object_id_offset(::uint32_t value);

  private:
  ::uint32_t _internal_object_id_offset() const;
  void _internal_set_object_id_offset(::uint32_t value);

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.Allocate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int kind_;
    ::uint32_t object_id_offset_;
    ::uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchAllocate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchAllocate) */ {
 public:
  inline BatchAllocate() : BatchAllocate(nullptr) {}
  ~BatchAllocate() override;
  explicit PROTOBUF_CONSTEXPR BatchAllocate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchAllocate(const BatchAllocate& from);
  BatchAllocate(BatchAllocate&& from) noexcept
    : BatchAllocate() {
    *this = ::std::move(from);
  }

  inline BatchAllocate& operator=(const BatchAllocate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchAllocate& operator=(BatchAllocate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchAllocate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchAllocate* internal_default_instance() {
    return reinterpret_cast<const BatchAllocate*>(
               &_BatchAllocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BatchAllocate& a, BatchAllocate& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchAllocate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchAllocate* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchAllocate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchAllocate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchAllocate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchAllocate& from) {
    BatchAllocate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchAllocate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchAllocate";
  }
  protected:
  explicit BatchAllocate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.Allocate items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::Allocate* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Allocate >*
      mutable_items();
  private:
  const ::l4m::Allocate& _internal_items(int index) const;
  ::l4m::Allocate* _internal_add_items();
  public:
  const ::l4m::Allocate& items(int index) const;
  ::l4m::Allocate* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Allocate >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchAllocate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Allocate > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class Deallocate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.Deallocate) */ {
 public:
  inline Deallocate() : Deallocate(nullptr) {}
  ~Deallocate() override;
  explicit PROTOBUF_CONSTEXPR Deallocate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Deallocate(const Deallocate& from);
  Deallocate(Deallocate&& from) noexcept
    : Deallocate() {
    *this = ::std::move(from);
  }

  inline Deallocate& operator=(const Deallocate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Deallocate& operator=(Deallocate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Deallocate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Deallocate* internal_default_instance() {
    return reinterpret_cast<const Deallocate*>(
               &_Deallocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Deallocate& a, Deallocate& b) {
    a.Swap(&b);
  }
  inline void Swap(Deallocate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Deallocate* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Deallocate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Deallocate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Deallocate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Deallocate& from) {
    Deallocate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deallocate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.Deallocate";
  }
  protected:
  explicit Deallocate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kObjectIdOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .l4m.ObjectKind kind = 1;
  void clear_kind() ;
  ::l4m::ObjectKind kind() const;
  void set_kind(::l4m::ObjectKind value);
  private:
  ::l4m::ObjectKind _internal_kind() const;
  void _internal_set_kind(::l4m::ObjectKind value);
  public:
  // uint32 object_id_offset = 2;
  void clear_object_id_offset() ;
  ::uint32_t object_id_offset() const;
  void set_object_id_offset(::uint32_t value);

  private:
  ::uint32_t _internal_object_id_offset() const;
  void _internal_set_object_id_offset(::uint32_t value);

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.Deallocate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int kind_;
    ::uint32_t object_id_offset_;
    ::uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchDeallocate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchDeallocate) */ {
 public:
  inline BatchDeallocate() : BatchDeallocate(nullptr) {}
  ~BatchDeallocate() override;
  explicit PROTOBUF_CONSTEXPR BatchDeallocate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDeallocate(const BatchDeallocate& from);
  BatchDeallocate(BatchDeallocate&& from) noexcept
    : BatchDeallocate() {
    *this = ::std::move(from);
  }

  inline BatchDeallocate& operator=(const BatchDeallocate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDeallocate& operator=(BatchDeallocate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDeallocate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDeallocate* internal_default_instance() {
    return reinterpret_cast<const BatchDeallocate*>(
               &_BatchDeallocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BatchDeallocate& a, BatchDeallocate& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDeallocate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDeallocate* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDeallocate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDeallocate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDeallocate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchDeallocate& from) {
    BatchDeallocate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDeallocate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchDeallocate";
  }
  protected:
  explicit BatchDeallocate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.Deallocate items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::Deallocate* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Deallocate >*
      mutable_items();
  private:
  const ::l4m::Deallocate& _internal_items(int index) const;
  ::l4m::Deallocate* _internal_add_items();
  public:
  const ::l4m::Deallocate& items(int index) const;
  ::l4m::Deallocate* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Deallocate >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchDeallocate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Deallocate > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class EmbedText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.EmbedText) */ {
 public:
  inline EmbedText() : EmbedText(nullptr) {}
  ~EmbedText() override;
  explicit PROTOBUF_CONSTEXPR EmbedText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmbedText(const EmbedText& from);
  EmbedText(EmbedText&& from) noexcept
    : EmbedText() {
    *this = ::std::move(from);
  }

  inline EmbedText& operator=(const EmbedText& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmbedText& operator=(EmbedText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmbedText& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmbedText* internal_default_instance() {
    return reinterpret_cast<const EmbedText*>(
               &_EmbedText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EmbedText& a, EmbedText& b) {
    a.Swap(&b);
  }
  inline void Swap(EmbedText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmbedText* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmbedText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmbedText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmbedText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmbedText& from) {
    EmbedText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmbedText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.EmbedText";
  }
  protected:
  explicit EmbedText(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmbeddingIdFieldNumber = 1,
    kTokenIdFieldNumber = 2,
    kPositionIdFieldNumber = 3,
  };
  // uint32 embedding_id = 1;
  void clear_embedding_id() ;
  ::uint32_t embedding_id() const;
  void set_embedding_id(::uint32_t value);

  private:
  ::uint32_t _internal_embedding_id() const;
  void _internal_set_embedding_id(::uint32_t value);

  public:
  // uint32 token_id = 2;
  void clear_token_id() ;
  ::uint32_t token_id() const;
  void set_token_id(::uint32_t value);

  private:
  ::uint32_t _internal_token_id() const;
  void _internal_set_token_id(::uint32_t value);

  public:
  // uint32 position_id = 3;
  void clear_position_id() ;
  ::uint32_t position_id() const;
  void set_position_id(::uint32_t value);

  private:
  ::uint32_t _internal_position_id() const;
  void _internal_set_position_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.EmbedText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t embedding_id_;
    ::uint32_t token_id_;
    ::uint32_t position_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchEmbedText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchEmbedText) */ {
 public:
  inline BatchEmbedText() : BatchEmbedText(nullptr) {}
  ~BatchEmbedText() override;
  explicit PROTOBUF_CONSTEXPR BatchEmbedText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchEmbedText(const BatchEmbedText& from);
  BatchEmbedText(BatchEmbedText&& from) noexcept
    : BatchEmbedText() {
    *this = ::std::move(from);
  }

  inline BatchEmbedText& operator=(const BatchEmbedText& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEmbedText& operator=(BatchEmbedText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEmbedText& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchEmbedText* internal_default_instance() {
    return reinterpret_cast<const BatchEmbedText*>(
               &_BatchEmbedText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchEmbedText& a, BatchEmbedText& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchEmbedText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEmbedText* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEmbedText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchEmbedText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchEmbedText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchEmbedText& from) {
    BatchEmbedText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchEmbedText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchEmbedText";
  }
  protected:
  explicit BatchEmbedText(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.EmbedText items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::EmbedText* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::EmbedText >*
      mutable_items();
  private:
  const ::l4m::EmbedText& _internal_items(int index) const;
  ::l4m::EmbedText* _internal_add_items();
  public:
  const ::l4m::EmbedText& items(int index) const;
  ::l4m::EmbedText* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::EmbedText >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchEmbedText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::EmbedText > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class FillBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.FillBlock) */ {
 public:
  inline FillBlock() : FillBlock(nullptr) {}
  ~FillBlock() override;
  explicit PROTOBUF_CONSTEXPR FillBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FillBlock(const FillBlock& from);
  FillBlock(FillBlock&& from) noexcept
    : FillBlock() {
    *this = ::std::move(from);
  }

  inline FillBlock& operator=(const FillBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillBlock& operator=(FillBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FillBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const FillBlock* internal_default_instance() {
    return reinterpret_cast<const FillBlock*>(
               &_FillBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FillBlock& a, FillBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(FillBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FillBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FillBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FillBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FillBlock& from) {
    FillBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.FillBlock";
  }
  protected:
  explicit FillBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextBlockIdsFieldNumber = 2,
    kInputEmbeddingIdsFieldNumber = 3,
    kOutputEmbeddingIdsFieldNumber = 4,
    kLastBlockLenFieldNumber = 1,
  };
  // repeated uint32 context_block_ids = 2;
  int context_block_ids_size() const;
  private:
  int _internal_context_block_ids_size() const;

  public:
  void clear_context_block_ids() ;
  ::uint32_t context_block_ids(int index) const;
  void set_context_block_ids(int index, ::uint32_t value);
  void add_context_block_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& context_block_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_context_block_ids();

  private:
  ::uint32_t _internal_context_block_ids(int index) const;
  void _internal_add_context_block_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_context_block_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_context_block_ids();

  public:
  // repeated uint32 input_embedding_ids = 3;
  int input_embedding_ids_size() const;
  private:
  int _internal_input_embedding_ids_size() const;

  public:
  void clear_input_embedding_ids() ;
  ::uint32_t input_embedding_ids(int index) const;
  void set_input_embedding_ids(int index, ::uint32_t value);
  void add_input_embedding_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& input_embedding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_input_embedding_ids();

  private:
  ::uint32_t _internal_input_embedding_ids(int index) const;
  void _internal_add_input_embedding_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_input_embedding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_input_embedding_ids();

  public:
  // repeated uint32 output_embedding_ids = 4;
  int output_embedding_ids_size() const;
  private:
  int _internal_output_embedding_ids_size() const;

  public:
  void clear_output_embedding_ids() ;
  ::uint32_t output_embedding_ids(int index) const;
  void set_output_embedding_ids(int index, ::uint32_t value);
  void add_output_embedding_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& output_embedding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_output_embedding_ids();

  private:
  ::uint32_t _internal_output_embedding_ids(int index) const;
  void _internal_add_output_embedding_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_output_embedding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_output_embedding_ids();

  public:
  // uint32 last_block_len = 1;
  void clear_last_block_len() ;
  ::uint32_t last_block_len() const;
  void set_last_block_len(::uint32_t value);

  private:
  ::uint32_t _internal_last_block_len() const;
  void _internal_set_last_block_len(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.FillBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> context_block_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _context_block_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> input_embedding_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _input_embedding_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> output_embedding_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _output_embedding_ids_cached_byte_size_;
    ::uint32_t last_block_len_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchFillBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchFillBlock) */ {
 public:
  inline BatchFillBlock() : BatchFillBlock(nullptr) {}
  ~BatchFillBlock() override;
  explicit PROTOBUF_CONSTEXPR BatchFillBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchFillBlock(const BatchFillBlock& from);
  BatchFillBlock(BatchFillBlock&& from) noexcept
    : BatchFillBlock() {
    *this = ::std::move(from);
  }

  inline BatchFillBlock& operator=(const BatchFillBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchFillBlock& operator=(BatchFillBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchFillBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchFillBlock* internal_default_instance() {
    return reinterpret_cast<const BatchFillBlock*>(
               &_BatchFillBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchFillBlock& a, BatchFillBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchFillBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchFillBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchFillBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchFillBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchFillBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchFillBlock& from) {
    BatchFillBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchFillBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchFillBlock";
  }
  protected:
  explicit BatchFillBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.FillBlock items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::FillBlock* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::FillBlock >*
      mutable_items();
  private:
  const ::l4m::FillBlock& _internal_items(int index) const;
  ::l4m::FillBlock* _internal_add_items();
  public:
  const ::l4m::FillBlock& items(int index) const;
  ::l4m::FillBlock* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::FillBlock >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchFillBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::FillBlock > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class MaskBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.MaskBlock) */ {
 public:
  inline MaskBlock() : MaskBlock(nullptr) {}
  ~MaskBlock() override;
  explicit PROTOBUF_CONSTEXPR MaskBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskBlock(const MaskBlock& from);
  MaskBlock(MaskBlock&& from) noexcept
    : MaskBlock() {
    *this = ::std::move(from);
  }

  inline MaskBlock& operator=(const MaskBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskBlock& operator=(MaskBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskBlock* internal_default_instance() {
    return reinterpret_cast<const MaskBlock*>(
               &_MaskBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MaskBlock& a, MaskBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaskBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaskBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaskBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaskBlock& from) {
    MaskBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.MaskBlock";
  }
  protected:
  explicit MaskBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 2,
    kBlockIdFieldNumber = 1,
  };
  // repeated bool mask = 2;
  int mask_size() const;
  private:
  int _internal_mask_size() const;

  public:
  void clear_mask() ;
  bool mask(int index) const;
  void set_mask(int index, bool value);
  void add_mask(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& mask() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_mask();

  private:
  bool _internal_mask(int index) const;
  void _internal_add_mask(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_mask() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_mask();

  public:
  // uint32 block_id = 1;
  void clear_block_id() ;
  ::uint32_t block_id() const;
  void set_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_block_id() const;
  void _internal_set_block_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.MaskBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> mask_;
    ::uint32_t block_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchMaskBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchMaskBlock) */ {
 public:
  inline BatchMaskBlock() : BatchMaskBlock(nullptr) {}
  ~BatchMaskBlock() override;
  explicit PROTOBUF_CONSTEXPR BatchMaskBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchMaskBlock(const BatchMaskBlock& from);
  BatchMaskBlock(BatchMaskBlock&& from) noexcept
    : BatchMaskBlock() {
    *this = ::std::move(from);
  }

  inline BatchMaskBlock& operator=(const BatchMaskBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchMaskBlock& operator=(BatchMaskBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchMaskBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchMaskBlock* internal_default_instance() {
    return reinterpret_cast<const BatchMaskBlock*>(
               &_BatchMaskBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BatchMaskBlock& a, BatchMaskBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchMaskBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchMaskBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchMaskBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchMaskBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchMaskBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchMaskBlock& from) {
    BatchMaskBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchMaskBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchMaskBlock";
  }
  protected:
  explicit BatchMaskBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.MaskBlock items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::MaskBlock* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::MaskBlock >*
      mutable_items();
  private:
  const ::l4m::MaskBlock& _internal_items(int index) const;
  ::l4m::MaskBlock* _internal_add_items();
  public:
  const ::l4m::MaskBlock& items(int index) const;
  ::l4m::MaskBlock* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::MaskBlock >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchMaskBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::MaskBlock > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class CopyBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.CopyBlock) */ {
 public:
  inline CopyBlock() : CopyBlock(nullptr) {}
  ~CopyBlock() override;
  explicit PROTOBUF_CONSTEXPR CopyBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyBlock(const CopyBlock& from);
  CopyBlock(CopyBlock&& from) noexcept
    : CopyBlock() {
    *this = ::std::move(from);
  }

  inline CopyBlock& operator=(const CopyBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyBlock& operator=(CopyBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyBlock* internal_default_instance() {
    return reinterpret_cast<const CopyBlock*>(
               &_CopyBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CopyBlock& a, CopyBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyBlock& from) {
    CopyBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.CopyBlock";
  }
  protected:
  explicit CopyBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceBlockIdFieldNumber = 1,
    kDestinationBlockIdFieldNumber = 2,
    kSourceStartFieldNumber = 3,
    kDestinationStartFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  // uint32 source_block_id = 1;
  void clear_source_block_id() ;
  ::uint32_t source_block_id() const;
  void set_source_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_source_block_id() const;
  void _internal_set_source_block_id(::uint32_t value);

  public:
  // uint32 destination_block_id = 2;
  void clear_destination_block_id() ;
  ::uint32_t destination_block_id() const;
  void set_destination_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_destination_block_id() const;
  void _internal_set_destination_block_id(::uint32_t value);

  public:
  // uint32 source_start = 3;
  void clear_source_start() ;
  ::uint32_t source_start() const;
  void set_source_start(::uint32_t value);

  private:
  ::uint32_t _internal_source_start() const;
  void _internal_set_source_start(::uint32_t value);

  public:
  // uint32 destination_start = 4;
  void clear_destination_start() ;
  ::uint32_t destination_start() const;
  void set_destination_start(::uint32_t value);

  private:
  ::uint32_t _internal_destination_start() const;
  void _internal_set_destination_start(::uint32_t value);

  public:
  // uint32 length = 5;
  void clear_length() ;
  ::uint32_t length() const;
  void set_length(::uint32_t value);

  private:
  ::uint32_t _internal_length() const;
  void _internal_set_length(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.CopyBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t source_block_id_;
    ::uint32_t destination_block_id_;
    ::uint32_t source_start_;
    ::uint32_t destination_start_;
    ::uint32_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchCopyBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchCopyBlock) */ {
 public:
  inline BatchCopyBlock() : BatchCopyBlock(nullptr) {}
  ~BatchCopyBlock() override;
  explicit PROTOBUF_CONSTEXPR BatchCopyBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCopyBlock(const BatchCopyBlock& from);
  BatchCopyBlock(BatchCopyBlock&& from) noexcept
    : BatchCopyBlock() {
    *this = ::std::move(from);
  }

  inline BatchCopyBlock& operator=(const BatchCopyBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCopyBlock& operator=(BatchCopyBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCopyBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCopyBlock* internal_default_instance() {
    return reinterpret_cast<const BatchCopyBlock*>(
               &_BatchCopyBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BatchCopyBlock& a, BatchCopyBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCopyBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCopyBlock* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCopyBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCopyBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCopyBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCopyBlock& from) {
    BatchCopyBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCopyBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchCopyBlock";
  }
  protected:
  explicit BatchCopyBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.CopyBlock items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::CopyBlock* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::CopyBlock >*
      mutable_items();
  private:
  const ::l4m::CopyBlock& _internal_items(int index) const;
  ::l4m::CopyBlock* _internal_add_items();
  public:
  const ::l4m::CopyBlock& items(int index) const;
  ::l4m::CopyBlock* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::CopyBlock >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchCopyBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::CopyBlock > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class DecodeTokenDistribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.DecodeTokenDistribution) */ {
 public:
  inline DecodeTokenDistribution() : DecodeTokenDistribution(nullptr) {}
  ~DecodeTokenDistribution() override;
  explicit PROTOBUF_CONSTEXPR DecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecodeTokenDistribution(const DecodeTokenDistribution& from);
  DecodeTokenDistribution(DecodeTokenDistribution&& from) noexcept
    : DecodeTokenDistribution() {
    *this = ::std::move(from);
  }

  inline DecodeTokenDistribution& operator=(const DecodeTokenDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecodeTokenDistribution& operator=(DecodeTokenDistribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecodeTokenDistribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecodeTokenDistribution* internal_default_instance() {
    return reinterpret_cast<const DecodeTokenDistribution*>(
               &_DecodeTokenDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DecodeTokenDistribution& a, DecodeTokenDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(DecodeTokenDistribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecodeTokenDistribution* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecodeTokenDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecodeTokenDistribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecodeTokenDistribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DecodeTokenDistribution& from) {
    DecodeTokenDistribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecodeTokenDistribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.DecodeTokenDistribution";
  }
  protected:
  explicit DecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmbeddingIdFieldNumber = 1,
    kDistributionIdFieldNumber = 2,
  };
  // uint32 embedding_id = 1;
  void clear_embedding_id() ;
  ::uint32_t embedding_id() const;
  void set_embedding_id(::uint32_t value);

  private:
  ::uint32_t _internal_embedding_id() const;
  void _internal_set_embedding_id(::uint32_t value);

  public:
  // uint32 distribution_id = 2;
  void clear_distribution_id() ;
  ::uint32_t distribution_id() const;
  void set_distribution_id(::uint32_t value);

  private:
  ::uint32_t _internal_distribution_id() const;
  void _internal_set_distribution_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.DecodeTokenDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t embedding_id_;
    ::uint32_t distribution_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchDecodeTokenDistribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchDecodeTokenDistribution) */ {
 public:
  inline BatchDecodeTokenDistribution() : BatchDecodeTokenDistribution(nullptr) {}
  ~BatchDecodeTokenDistribution() override;
  explicit PROTOBUF_CONSTEXPR BatchDecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDecodeTokenDistribution(const BatchDecodeTokenDistribution& from);
  BatchDecodeTokenDistribution(BatchDecodeTokenDistribution&& from) noexcept
    : BatchDecodeTokenDistribution() {
    *this = ::std::move(from);
  }

  inline BatchDecodeTokenDistribution& operator=(const BatchDecodeTokenDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDecodeTokenDistribution& operator=(BatchDecodeTokenDistribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDecodeTokenDistribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDecodeTokenDistribution* internal_default_instance() {
    return reinterpret_cast<const BatchDecodeTokenDistribution*>(
               &_BatchDecodeTokenDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BatchDecodeTokenDistribution& a, BatchDecodeTokenDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDecodeTokenDistribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDecodeTokenDistribution* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDecodeTokenDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDecodeTokenDistribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDecodeTokenDistribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchDecodeTokenDistribution& from) {
    BatchDecodeTokenDistribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDecodeTokenDistribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchDecodeTokenDistribution";
  }
  protected:
  explicit BatchDecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.DecodeTokenDistribution items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::DecodeTokenDistribution* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::DecodeTokenDistribution >*
      mutable_items();
  private:
  const ::l4m::DecodeTokenDistribution& _internal_items(int index) const;
  ::l4m::DecodeTokenDistribution* _internal_add_items();
  public:
  const ::l4m::DecodeTokenDistribution& items(int index) const;
  ::l4m::DecodeTokenDistribution* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::DecodeTokenDistribution >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchDecodeTokenDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::DecodeTokenDistribution > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class SampleTopKRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.SampleTopKRequest) */ {
 public:
  inline SampleTopKRequest() : SampleTopKRequest(nullptr) {}
  ~SampleTopKRequest() override;
  explicit PROTOBUF_CONSTEXPR SampleTopKRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SampleTopKRequest(const SampleTopKRequest& from);
  SampleTopKRequest(SampleTopKRequest&& from) noexcept
    : SampleTopKRequest() {
    *this = ::std::move(from);
  }

  inline SampleTopKRequest& operator=(const SampleTopKRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SampleTopKRequest& operator=(SampleTopKRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SampleTopKRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SampleTopKRequest* internal_default_instance() {
    return reinterpret_cast<const SampleTopKRequest*>(
               &_SampleTopKRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SampleTopKRequest& a, SampleTopKRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SampleTopKRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SampleTopKRequest* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SampleTopKRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SampleTopKRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SampleTopKRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SampleTopKRequest& from) {
    SampleTopKRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SampleTopKRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.SampleTopKRequest";
  }
  protected:
  explicit SampleTopKRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistributionIdFieldNumber = 1,
    kKFieldNumber = 2,
  };
  // uint32 distribution_id = 1;
  void clear_distribution_id() ;
  ::uint32_t distribution_id() const;
  void set_distribution_id(::uint32_t value);

  private:
  ::uint32_t _internal_distribution_id() const;
  void _internal_set_distribution_id(::uint32_t value);

  public:
  // uint32 k = 2;
  void clear_k() ;
  ::uint32_t k() const;
  void set_k(::uint32_t value);

  private:
  ::uint32_t _internal_k() const;
  void _internal_set_k(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.SampleTopKRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t distribution_id_;
    ::uint32_t k_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchSampleTopKRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchSampleTopKRequest) */ {
 public:
  inline BatchSampleTopKRequest() : BatchSampleTopKRequest(nullptr) {}
  ~BatchSampleTopKRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchSampleTopKRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchSampleTopKRequest(const BatchSampleTopKRequest& from);
  BatchSampleTopKRequest(BatchSampleTopKRequest&& from) noexcept
    : BatchSampleTopKRequest() {
    *this = ::std::move(from);
  }

  inline BatchSampleTopKRequest& operator=(const BatchSampleTopKRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchSampleTopKRequest& operator=(BatchSampleTopKRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchSampleTopKRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchSampleTopKRequest* internal_default_instance() {
    return reinterpret_cast<const BatchSampleTopKRequest*>(
               &_BatchSampleTopKRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BatchSampleTopKRequest& a, BatchSampleTopKRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchSampleTopKRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchSampleTopKRequest* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchSampleTopKRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchSampleTopKRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchSampleTopKRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchSampleTopKRequest& from) {
    BatchSampleTopKRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchSampleTopKRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchSampleTopKRequest";
  }
  protected:
  explicit BatchSampleTopKRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.SampleTopKRequest items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::SampleTopKRequest* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKRequest >*
      mutable_items();
  private:
  const ::l4m::SampleTopKRequest& _internal_items(int index) const;
  ::l4m::SampleTopKRequest* _internal_add_items();
  public:
  const ::l4m::SampleTopKRequest& items(int index) const;
  ::l4m::SampleTopKRequest* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKRequest >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchSampleTopKRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKRequest > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class SampleTopKResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.SampleTopKResponse) */ {
 public:
  inline SampleTopKResponse() : SampleTopKResponse(nullptr) {}
  ~SampleTopKResponse() override;
  explicit PROTOBUF_CONSTEXPR SampleTopKResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SampleTopKResponse(const SampleTopKResponse& from);
  SampleTopKResponse(SampleTopKResponse&& from) noexcept
    : SampleTopKResponse() {
    *this = ::std::move(from);
  }

  inline SampleTopKResponse& operator=(const SampleTopKResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SampleTopKResponse& operator=(SampleTopKResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SampleTopKResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SampleTopKResponse* internal_default_instance() {
    return reinterpret_cast<const SampleTopKResponse*>(
               &_SampleTopKResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SampleTopKResponse& a, SampleTopKResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SampleTopKResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SampleTopKResponse* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SampleTopKResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SampleTopKResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SampleTopKResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SampleTopKResponse& from) {
    SampleTopKResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SampleTopKResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.SampleTopKResponse";
  }
  protected:
  explicit SampleTopKResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdsFieldNumber = 1,
    kProbabilitiesFieldNumber = 2,
  };
  // repeated uint32 token_ids = 1;
  int token_ids_size() const;
  private:
  int _internal_token_ids_size() const;

  public:
  void clear_token_ids() ;
  ::uint32_t token_ids(int index) const;
  void set_token_ids(int index, ::uint32_t value);
  void add_token_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& token_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_token_ids();

  private:
  ::uint32_t _internal_token_ids(int index) const;
  void _internal_add_token_ids(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_token_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_token_ids();

  public:
  // repeated float probabilities = 2;
  int probabilities_size() const;
  private:
  int _internal_probabilities_size() const;

  public:
  void clear_probabilities() ;
  float probabilities(int index) const;
  void set_probabilities(int index, float value);
  void add_probabilities(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& probabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* mutable_probabilities();

  private:
  float _internal_probabilities(int index) const;
  void _internal_add_probabilities(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& _internal_probabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* _internal_mutable_probabilities();

  public:
  // @@protoc_insertion_point(class_scope:l4m.SampleTopKResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> token_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _token_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float> probabilities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class BatchSampleTopKResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.BatchSampleTopKResponse) */ {
 public:
  inline BatchSampleTopKResponse() : BatchSampleTopKResponse(nullptr) {}
  ~BatchSampleTopKResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchSampleTopKResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchSampleTopKResponse(const BatchSampleTopKResponse& from);
  BatchSampleTopKResponse(BatchSampleTopKResponse&& from) noexcept
    : BatchSampleTopKResponse() {
    *this = ::std::move(from);
  }

  inline BatchSampleTopKResponse& operator=(const BatchSampleTopKResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchSampleTopKResponse& operator=(BatchSampleTopKResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchSampleTopKResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchSampleTopKResponse* internal_default_instance() {
    return reinterpret_cast<const BatchSampleTopKResponse*>(
               &_BatchSampleTopKResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BatchSampleTopKResponse& a, BatchSampleTopKResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchSampleTopKResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchSampleTopKResponse* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchSampleTopKResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchSampleTopKResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchSampleTopKResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchSampleTopKResponse& from) {
    BatchSampleTopKResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchSampleTopKResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.BatchSampleTopKResponse";
  }
  protected:
  explicit BatchSampleTopKResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .l4m.SampleTopKResponse items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::l4m::SampleTopKResponse* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKResponse >*
      mutable_items();
  private:
  const ::l4m::SampleTopKResponse& _internal_items(int index) const;
  ::l4m::SampleTopKResponse* _internal_add_items();
  public:
  const ::l4m::SampleTopKResponse& items(int index) const;
  ::l4m::SampleTopKResponse* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKResponse >&
      items() const;
  // @@protoc_insertion_point(class_scope:l4m.BatchSampleTopKResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKResponse > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class GetInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:l4m.GetInfoRequest) */ {
 public:
  inline GetInfoRequest() : GetInfoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInfoRequest(const GetInfoRequest& from);
  GetInfoRequest(GetInfoRequest&& from) noexcept
    : GetInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetInfoRequest& operator=(const GetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoRequest& operator=(GetInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetInfoRequest*>(
               &_GetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetInfoRequest& a, GetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoRequest* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.GetInfoRequest";
  }
  protected:
  explicit GetInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:l4m.GetInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class GetInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.GetInfoResponse) */ {
 public:
  inline GetInfoResponse() : GetInfoResponse(nullptr) {}
  ~GetInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInfoResponse(const GetInfoResponse& from);
  GetInfoResponse(GetInfoResponse&& from) noexcept
    : GetInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetInfoResponse& operator=(const GetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoResponse& operator=(GetInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetInfoResponse*>(
               &_GetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetInfoResponse& a, GetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoResponse* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInfoResponse& from) {
    GetInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.GetInfoResponse";
  }
  protected:
  explicit GetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kModelNameFieldNumber = 2,
    kBlockSizeFieldNumber = 3,
    kNumAvailableBlocksFieldNumber = 4,
    kNumAvailableEmbeddingsFieldNumber = 5,
    kNumAvailableDistributionsFieldNumber = 6,
  };
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:
  // string model_name = 2;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:
  // uint32 block_size = 3;
  void clear_block_size() ;
  ::uint32_t block_size() const;
  void set_block_size(::uint32_t value);

  private:
  ::uint32_t _internal_block_size() const;
  void _internal_set_block_size(::uint32_t value);

  public:
  // uint32 num_available_blocks = 4;
  void clear_num_available_blocks() ;
  ::uint32_t num_available_blocks() const;
  void set_num_available_blocks(::uint32_t value);

  private:
  ::uint32_t _internal_num_available_blocks() const;
  void _internal_set_num_available_blocks(::uint32_t value);

  public:
  // uint32 num_available_embeddings = 5;
  void clear_num_available_embeddings() ;
  ::uint32_t num_available_embeddings() const;
  void set_num_available_embeddings(::uint32_t value);

  private:
  ::uint32_t _internal_num_available_embeddings() const;
  void _internal_set_num_available_embeddings(::uint32_t value);

  public:
  // uint32 num_available_distributions = 6;
  void clear_num_available_distributions() ;
  ::uint32_t num_available_distributions() const;
  void set_num_available_distributions(::uint32_t value);

  private:
  ::uint32_t _internal_num_available_distributions() const;
  void _internal_set_num_available_distributions(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:l4m.GetInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::uint32_t block_size_;
    ::uint32_t num_available_blocks_;
    ::uint32_t num_available_embeddings_;
    ::uint32_t num_available_distributions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kAllocate = 2,
    kDeallocate = 3,
    kEmbedText = 4,
    kFillBlock = 5,
    kMaskBlock = 6,
    kCopyBlock = 7,
    kDecodeTokenDistribution = 8,
    kSampleTopKRequest = 9,
    kGetInfo = 10,
    COMMAND_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorrelationIdFieldNumber = 1,
    kAllocateFieldNumber = 2,
    kDeallocateFieldNumber = 3,
    kEmbedTextFieldNumber = 4,
    kFillBlockFieldNumber = 5,
    kMaskBlockFieldNumber = 6,
    kCopyBlockFieldNumber = 7,
    kDecodeTokenDistributionFieldNumber = 8,
    kSampleTopKRequestFieldNumber = 9,
    kGetInfoFieldNumber = 10,
  };
  // uint32 correlation_id = 1;
  void clear_correlation_id() ;
  ::uint32_t correlation_id() const;
  void set_correlation_id(::uint32_t value);

  private:
  ::uint32_t _internal_correlation_id() const;
  void _internal_set_correlation_id(::uint32_t value);

  public:
  // .l4m.BatchAllocate allocate = 2;
  bool has_allocate() const;
  private:
  bool _internal_has_allocate() const;

  public:
  void clear_allocate() ;
  const ::l4m::BatchAllocate& allocate() const;
  PROTOBUF_NODISCARD ::l4m::BatchAllocate* release_allocate();
  ::l4m::BatchAllocate* mutable_allocate();
  void set_allocated_allocate(::l4m::BatchAllocate* allocate);
  private:
  const ::l4m::BatchAllocate& _internal_allocate() const;
  ::l4m::BatchAllocate* _internal_mutable_allocate();
  public:
  void unsafe_arena_set_allocated_allocate(
      ::l4m::BatchAllocate* allocate);
  ::l4m::BatchAllocate* unsafe_arena_release_allocate();
  // .l4m.BatchDeallocate deallocate = 3;
  bool has_deallocate() const;
  private:
  bool _internal_has_deallocate() const;

  public:
  void clear_deallocate() ;
  const ::l4m::BatchDeallocate& deallocate() const;
  PROTOBUF_NODISCARD ::l4m::BatchDeallocate* release_deallocate();
  ::l4m::BatchDeallocate* mutable_deallocate();
  void set_allocated_deallocate(::l4m::BatchDeallocate* deallocate);
  private:
  const ::l4m::BatchDeallocate& _internal_deallocate() const;
  ::l4m::BatchDeallocate* _internal_mutable_deallocate();
  public:
  void unsafe_arena_set_allocated_deallocate(
      ::l4m::BatchDeallocate* deallocate);
  ::l4m::BatchDeallocate* unsafe_arena_release_deallocate();
  // .l4m.BatchEmbedText embed_text = 4;
  bool has_embed_text() const;
  private:
  bool _internal_has_embed_text() const;

  public:
  void clear_embed_text() ;
  const ::l4m::BatchEmbedText& embed_text() const;
  PROTOBUF_NODISCARD ::l4m::BatchEmbedText* release_embed_text();
  ::l4m::BatchEmbedText* mutable_embed_text();
  void set_allocated_embed_text(::l4m::BatchEmbedText* embed_text);
  private:
  const ::l4m::BatchEmbedText& _internal_embed_text() const;
  ::l4m::BatchEmbedText* _internal_mutable_embed_text();
  public:
  void unsafe_arena_set_allocated_embed_text(
      ::l4m::BatchEmbedText* embed_text);
  ::l4m::BatchEmbedText* unsafe_arena_release_embed_text();
  // .l4m.BatchFillBlock fill_block = 5;
  bool has_fill_block() const;
  private:
  bool _internal_has_fill_block() const;

  public:
  void clear_fill_block() ;
  const ::l4m::BatchFillBlock& fill_block() const;
  PROTOBUF_NODISCARD ::l4m::BatchFillBlock* release_fill_block();
  ::l4m::BatchFillBlock* mutable_fill_block();
  void set_allocated_fill_block(::l4m::BatchFillBlock* fill_block);
  private:
  const ::l4m::BatchFillBlock& _internal_fill_block() const;
  ::l4m::BatchFillBlock* _internal_mutable_fill_block();
  public:
  void unsafe_arena_set_allocated_fill_block(
      ::l4m::BatchFillBlock* fill_block);
  ::l4m::BatchFillBlock* unsafe_arena_release_fill_block();
  // .l4m.BatchMaskBlock mask_block = 6;
  bool has_mask_block() const;
  private:
  bool _internal_has_mask_block() const;

  public:
  void clear_mask_block() ;
  const ::l4m::BatchMaskBlock& mask_block() const;
  PROTOBUF_NODISCARD ::l4m::BatchMaskBlock* release_mask_block();
  ::l4m::BatchMaskBlock* mutable_mask_block();
  void set_allocated_mask_block(::l4m::BatchMaskBlock* mask_block);
  private:
  const ::l4m::BatchMaskBlock& _internal_mask_block() const;
  ::l4m::BatchMaskBlock* _internal_mutable_mask_block();
  public:
  void unsafe_arena_set_allocated_mask_block(
      ::l4m::BatchMaskBlock* mask_block);
  ::l4m::BatchMaskBlock* unsafe_arena_release_mask_block();
  // .l4m.BatchCopyBlock copy_block = 7;
  bool has_copy_block() const;
  private:
  bool _internal_has_copy_block() const;

  public:
  void clear_copy_block() ;
  const ::l4m::BatchCopyBlock& copy_block() const;
  PROTOBUF_NODISCARD ::l4m::BatchCopyBlock* release_copy_block();
  ::l4m::BatchCopyBlock* mutable_copy_block();
  void set_allocated_copy_block(::l4m::BatchCopyBlock* copy_block);
  private:
  const ::l4m::BatchCopyBlock& _internal_copy_block() const;
  ::l4m::BatchCopyBlock* _internal_mutable_copy_block();
  public:
  void unsafe_arena_set_allocated_copy_block(
      ::l4m::BatchCopyBlock* copy_block);
  ::l4m::BatchCopyBlock* unsafe_arena_release_copy_block();
  // .l4m.BatchDecodeTokenDistribution decode_token_distribution = 8;
  bool has_decode_token_distribution() const;
  private:
  bool _internal_has_decode_token_distribution() const;

  public:
  void clear_decode_token_distribution() ;
  const ::l4m::BatchDecodeTokenDistribution& decode_token_distribution() const;
  PROTOBUF_NODISCARD ::l4m::BatchDecodeTokenDistribution* release_decode_token_distribution();
  ::l4m::BatchDecodeTokenDistribution* mutable_decode_token_distribution();
  void set_allocated_decode_token_distribution(::l4m::BatchDecodeTokenDistribution* decode_token_distribution);
  private:
  const ::l4m::BatchDecodeTokenDistribution& _internal_decode_token_distribution() const;
  ::l4m::BatchDecodeTokenDistribution* _internal_mutable_decode_token_distribution();
  public:
  void unsafe_arena_set_allocated_decode_token_distribution(
      ::l4m::BatchDecodeTokenDistribution* decode_token_distribution);
  ::l4m::BatchDecodeTokenDistribution* unsafe_arena_release_decode_token_distribution();
  // .l4m.BatchSampleTopKRequest sample_top_k_request = 9;
  bool has_sample_top_k_request() const;
  private:
  bool _internal_has_sample_top_k_request() const;

  public:
  void clear_sample_top_k_request() ;
  const ::l4m::BatchSampleTopKRequest& sample_top_k_request() const;
  PROTOBUF_NODISCARD ::l4m::BatchSampleTopKRequest* release_sample_top_k_request();
  ::l4m::BatchSampleTopKRequest* mutable_sample_top_k_request();
  void set_allocated_sample_top_k_request(::l4m::BatchSampleTopKRequest* sample_top_k_request);
  private:
  const ::l4m::BatchSampleTopKRequest& _internal_sample_top_k_request() const;
  ::l4m::BatchSampleTopKRequest* _internal_mutable_sample_top_k_request();
  public:
  void unsafe_arena_set_allocated_sample_top_k_request(
      ::l4m::BatchSampleTopKRequest* sample_top_k_request);
  ::l4m::BatchSampleTopKRequest* unsafe_arena_release_sample_top_k_request();
  // .l4m.GetInfoRequest get_info = 10;
  bool has_get_info() const;
  private:
  bool _internal_has_get_info() const;

  public:
  void clear_get_info() ;
  const ::l4m::GetInfoRequest& get_info() const;
  PROTOBUF_NODISCARD ::l4m::GetInfoRequest* release_get_info();
  ::l4m::GetInfoRequest* mutable_get_info();
  void set_allocated_get_info(::l4m::GetInfoRequest* get_info);
  private:
  const ::l4m::GetInfoRequest& _internal_get_info() const;
  ::l4m::GetInfoRequest* _internal_mutable_get_info();
  public:
  void unsafe_arena_set_allocated_get_info(
      ::l4m::GetInfoRequest* get_info);
  ::l4m::GetInfoRequest* unsafe_arena_release_get_info();
  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:l4m.Request)
 private:
  class _Internal;
  void set_has_allocate();
  void set_has_deallocate();
  void set_has_embed_text();
  void set_has_fill_block();
  void set_has_mask_block();
  void set_has_copy_block();
  void set_has_decode_token_distribution();
  void set_has_sample_top_k_request();
  void set_has_get_info();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t correlation_id_;
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::l4m::BatchAllocate* allocate_;
      ::l4m::BatchDeallocate* deallocate_;
      ::l4m::BatchEmbedText* embed_text_;
      ::l4m::BatchFillBlock* fill_block_;
      ::l4m::BatchMaskBlock* mask_block_;
      ::l4m::BatchCopyBlock* copy_block_;
      ::l4m::BatchDecodeTokenDistribution* decode_token_distribution_;
      ::l4m::BatchSampleTopKRequest* sample_top_k_request_;
      ::l4m::GetInfoRequest* get_info_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:l4m.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kSampleTopK = 2,
    kGetInfo = 3,
    COMMAND_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "l4m.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorrelationIdFieldNumber = 1,
    kSampleTopKFieldNumber = 2,
    kGetInfoFieldNumber = 3,
  };
  // uint32 correlation_id = 1;
  void clear_correlation_id() ;
  ::uint32_t correlation_id() const;
  void set_correlation_id(::uint32_t value);

  private:
  ::uint32_t _internal_correlation_id() const;
  void _internal_set_correlation_id(::uint32_t value);

  public:
  // .l4m.BatchSampleTopKResponse sample_top_k = 2;
  bool has_sample_top_k() const;
  private:
  bool _internal_has_sample_top_k() const;

  public:
  void clear_sample_top_k() ;
  const ::l4m::BatchSampleTopKResponse& sample_top_k() const;
  PROTOBUF_NODISCARD ::l4m::BatchSampleTopKResponse* release_sample_top_k();
  ::l4m::BatchSampleTopKResponse* mutable_sample_top_k();
  void set_allocated_sample_top_k(::l4m::BatchSampleTopKResponse* sample_top_k);
  private:
  const ::l4m::BatchSampleTopKResponse& _internal_sample_top_k() const;
  ::l4m::BatchSampleTopKResponse* _internal_mutable_sample_top_k();
  public:
  void unsafe_arena_set_allocated_sample_top_k(
      ::l4m::BatchSampleTopKResponse* sample_top_k);
  ::l4m::BatchSampleTopKResponse* unsafe_arena_release_sample_top_k();
  // .l4m.GetInfoResponse get_info = 3;
  bool has_get_info() const;
  private:
  bool _internal_has_get_info() const;

  public:
  void clear_get_info() ;
  const ::l4m::GetInfoResponse& get_info() const;
  PROTOBUF_NODISCARD ::l4m::GetInfoResponse* release_get_info();
  ::l4m::GetInfoResponse* mutable_get_info();
  void set_allocated_get_info(::l4m::GetInfoResponse* get_info);
  private:
  const ::l4m::GetInfoResponse& _internal_get_info() const;
  ::l4m::GetInfoResponse* _internal_mutable_get_info();
  public:
  void unsafe_arena_set_allocated_get_info(
      ::l4m::GetInfoResponse* get_info);
  ::l4m::GetInfoResponse* unsafe_arena_release_get_info();
  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:l4m.Response)
 private:
  class _Internal;
  void set_has_sample_top_k();
  void set_has_get_info();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t correlation_id_;
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::l4m::BatchSampleTopKResponse* sample_top_k_;
      ::l4m::GetInfoResponse* get_info_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_l4m_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Allocate

// .l4m.ObjectKind kind = 1;
inline void Allocate::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::l4m::ObjectKind Allocate::_internal_kind() const {
  return static_cast< ::l4m::ObjectKind >(_impl_.kind_);
}
inline ::l4m::ObjectKind Allocate::kind() const {
  // @@protoc_insertion_point(field_get:l4m.Allocate.kind)
  return _internal_kind();
}
inline void Allocate::_internal_set_kind(::l4m::ObjectKind value) {
  
  _impl_.kind_ = value;
}
inline void Allocate::set_kind(::l4m::ObjectKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:l4m.Allocate.kind)
}

// uint32 object_id_offset = 2;
inline void Allocate::clear_object_id_offset() {
  _impl_.object_id_offset_ = 0u;
}
inline ::uint32_t Allocate::object_id_offset() const {
  // @@protoc_insertion_point(field_get:l4m.Allocate.object_id_offset)
  return _internal_object_id_offset();
}
inline void Allocate::set_object_id_offset(::uint32_t value) {
  ;
  _internal_set_object_id_offset(value);
  // @@protoc_insertion_point(field_set:l4m.Allocate.object_id_offset)
}
inline ::uint32_t Allocate::_internal_object_id_offset() const {
  return _impl_.object_id_offset_;
}
inline void Allocate::_internal_set_object_id_offset(::uint32_t value) {
  ;
  _impl_.object_id_offset_ = value;
}

// uint32 count = 3;
inline void Allocate::clear_count() {
  _impl_.count_ = 0u;
}
inline ::uint32_t Allocate::count() const {
  // @@protoc_insertion_point(field_get:l4m.Allocate.count)
  return _internal_count();
}
inline void Allocate::set_count(::uint32_t value) {
  ;
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:l4m.Allocate.count)
}
inline ::uint32_t Allocate::_internal_count() const {
  return _impl_.count_;
}
inline void Allocate::_internal_set_count(::uint32_t value) {
  ;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// BatchAllocate

// repeated .l4m.Allocate items = 1;
inline int BatchAllocate::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchAllocate::items_size() const {
  return _internal_items_size();
}
inline void BatchAllocate::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::Allocate* BatchAllocate::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchAllocate.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Allocate >*
BatchAllocate::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchAllocate.items)
  return &_impl_.items_;
}
inline const ::l4m::Allocate& BatchAllocate::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::Allocate& BatchAllocate::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchAllocate.items)
  return _internal_items(index);
}
inline ::l4m::Allocate* BatchAllocate::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::Allocate* BatchAllocate::add_items() {
  ::l4m::Allocate* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchAllocate.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Allocate >&
BatchAllocate::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchAllocate.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Deallocate

// .l4m.ObjectKind kind = 1;
inline void Deallocate::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::l4m::ObjectKind Deallocate::_internal_kind() const {
  return static_cast< ::l4m::ObjectKind >(_impl_.kind_);
}
inline ::l4m::ObjectKind Deallocate::kind() const {
  // @@protoc_insertion_point(field_get:l4m.Deallocate.kind)
  return _internal_kind();
}
inline void Deallocate::_internal_set_kind(::l4m::ObjectKind value) {
  
  _impl_.kind_ = value;
}
inline void Deallocate::set_kind(::l4m::ObjectKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:l4m.Deallocate.kind)
}

// uint32 object_id_offset = 2;
inline void Deallocate::clear_object_id_offset() {
  _impl_.object_id_offset_ = 0u;
}
inline ::uint32_t Deallocate::object_id_offset() const {
  // @@protoc_insertion_point(field_get:l4m.Deallocate.object_id_offset)
  return _internal_object_id_offset();
}
inline void Deallocate::set_object_id_offset(::uint32_t value) {
  ;
  _internal_set_object_id_offset(value);
  // @@protoc_insertion_point(field_set:l4m.Deallocate.object_id_offset)
}
inline ::uint32_t Deallocate::_internal_object_id_offset() const {
  return _impl_.object_id_offset_;
}
inline void Deallocate::_internal_set_object_id_offset(::uint32_t value) {
  ;
  _impl_.object_id_offset_ = value;
}

// uint32 count = 3;
inline void Deallocate::clear_count() {
  _impl_.count_ = 0u;
}
inline ::uint32_t Deallocate::count() const {
  // @@protoc_insertion_point(field_get:l4m.Deallocate.count)
  return _internal_count();
}
inline void Deallocate::set_count(::uint32_t value) {
  ;
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:l4m.Deallocate.count)
}
inline ::uint32_t Deallocate::_internal_count() const {
  return _impl_.count_;
}
inline void Deallocate::_internal_set_count(::uint32_t value) {
  ;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// BatchDeallocate

// repeated .l4m.Deallocate items = 1;
inline int BatchDeallocate::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchDeallocate::items_size() const {
  return _internal_items_size();
}
inline void BatchDeallocate::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::Deallocate* BatchDeallocate::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchDeallocate.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Deallocate >*
BatchDeallocate::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchDeallocate.items)
  return &_impl_.items_;
}
inline const ::l4m::Deallocate& BatchDeallocate::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::Deallocate& BatchDeallocate::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchDeallocate.items)
  return _internal_items(index);
}
inline ::l4m::Deallocate* BatchDeallocate::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::Deallocate* BatchDeallocate::add_items() {
  ::l4m::Deallocate* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchDeallocate.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::Deallocate >&
BatchDeallocate::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchDeallocate.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// EmbedText

// uint32 embedding_id = 1;
inline void EmbedText::clear_embedding_id() {
  _impl_.embedding_id_ = 0u;
}
inline ::uint32_t EmbedText::embedding_id() const {
  // @@protoc_insertion_point(field_get:l4m.EmbedText.embedding_id)
  return _internal_embedding_id();
}
inline void EmbedText::set_embedding_id(::uint32_t value) {
  ;
  _internal_set_embedding_id(value);
  // @@protoc_insertion_point(field_set:l4m.EmbedText.embedding_id)
}
inline ::uint32_t EmbedText::_internal_embedding_id() const {
  return _impl_.embedding_id_;
}
inline void EmbedText::_internal_set_embedding_id(::uint32_t value) {
  ;
  _impl_.embedding_id_ = value;
}

// uint32 token_id = 2;
inline void EmbedText::clear_token_id() {
  _impl_.token_id_ = 0u;
}
inline ::uint32_t EmbedText::token_id() const {
  // @@protoc_insertion_point(field_get:l4m.EmbedText.token_id)
  return _internal_token_id();
}
inline void EmbedText::set_token_id(::uint32_t value) {
  ;
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:l4m.EmbedText.token_id)
}
inline ::uint32_t EmbedText::_internal_token_id() const {
  return _impl_.token_id_;
}
inline void EmbedText::_internal_set_token_id(::uint32_t value) {
  ;
  _impl_.token_id_ = value;
}

// uint32 position_id = 3;
inline void EmbedText::clear_position_id() {
  _impl_.position_id_ = 0u;
}
inline ::uint32_t EmbedText::position_id() const {
  // @@protoc_insertion_point(field_get:l4m.EmbedText.position_id)
  return _internal_position_id();
}
inline void EmbedText::set_position_id(::uint32_t value) {
  ;
  _internal_set_position_id(value);
  // @@protoc_insertion_point(field_set:l4m.EmbedText.position_id)
}
inline ::uint32_t EmbedText::_internal_position_id() const {
  return _impl_.position_id_;
}
inline void EmbedText::_internal_set_position_id(::uint32_t value) {
  ;
  _impl_.position_id_ = value;
}

// -------------------------------------------------------------------

// BatchEmbedText

// repeated .l4m.EmbedText items = 1;
inline int BatchEmbedText::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchEmbedText::items_size() const {
  return _internal_items_size();
}
inline void BatchEmbedText::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::EmbedText* BatchEmbedText::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchEmbedText.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::EmbedText >*
BatchEmbedText::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchEmbedText.items)
  return &_impl_.items_;
}
inline const ::l4m::EmbedText& BatchEmbedText::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::EmbedText& BatchEmbedText::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchEmbedText.items)
  return _internal_items(index);
}
inline ::l4m::EmbedText* BatchEmbedText::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::EmbedText* BatchEmbedText::add_items() {
  ::l4m::EmbedText* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchEmbedText.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::EmbedText >&
BatchEmbedText::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchEmbedText.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// FillBlock

// uint32 last_block_len = 1;
inline void FillBlock::clear_last_block_len() {
  _impl_.last_block_len_ = 0u;
}
inline ::uint32_t FillBlock::last_block_len() const {
  // @@protoc_insertion_point(field_get:l4m.FillBlock.last_block_len)
  return _internal_last_block_len();
}
inline void FillBlock::set_last_block_len(::uint32_t value) {
  ;
  _internal_set_last_block_len(value);
  // @@protoc_insertion_point(field_set:l4m.FillBlock.last_block_len)
}
inline ::uint32_t FillBlock::_internal_last_block_len() const {
  return _impl_.last_block_len_;
}
inline void FillBlock::_internal_set_last_block_len(::uint32_t value) {
  ;
  _impl_.last_block_len_ = value;
}

// repeated uint32 context_block_ids = 2;
inline int FillBlock::_internal_context_block_ids_size() const {
  return _impl_.context_block_ids_.size();
}
inline int FillBlock::context_block_ids_size() const {
  return _internal_context_block_ids_size();
}
inline void FillBlock::clear_context_block_ids() {
  _impl_.context_block_ids_.Clear();
}
inline ::uint32_t FillBlock::context_block_ids(int index) const {
  // @@protoc_insertion_point(field_get:l4m.FillBlock.context_block_ids)
  return _internal_context_block_ids(index);
}
inline void FillBlock::set_context_block_ids(int index, ::uint32_t value) {
  _impl_.context_block_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.FillBlock.context_block_ids)
}
inline void FillBlock::add_context_block_ids(::uint32_t value) {
  _internal_add_context_block_ids(value);
  // @@protoc_insertion_point(field_add:l4m.FillBlock.context_block_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::context_block_ids() const {
  // @@protoc_insertion_point(field_list:l4m.FillBlock.context_block_ids)
  return _internal_context_block_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::mutable_context_block_ids() {
  // @@protoc_insertion_point(field_mutable_list:l4m.FillBlock.context_block_ids)
  return _internal_mutable_context_block_ids();
}

inline ::uint32_t FillBlock::_internal_context_block_ids(int index) const {
  return _impl_.context_block_ids_.Get(index);
}
inline void FillBlock::_internal_add_context_block_ids(::uint32_t value) { _impl_.context_block_ids_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::_internal_context_block_ids() const {
  return _impl_.context_block_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::_internal_mutable_context_block_ids() {
  return &_impl_.context_block_ids_;
}

// repeated uint32 input_embedding_ids = 3;
inline int FillBlock::_internal_input_embedding_ids_size() const {
  return _impl_.input_embedding_ids_.size();
}
inline int FillBlock::input_embedding_ids_size() const {
  return _internal_input_embedding_ids_size();
}
inline void FillBlock::clear_input_embedding_ids() {
  _impl_.input_embedding_ids_.Clear();
}
inline ::uint32_t FillBlock::input_embedding_ids(int index) const {
  // @@protoc_insertion_point(field_get:l4m.FillBlock.input_embedding_ids)
  return _internal_input_embedding_ids(index);
}
inline void FillBlock::set_input_embedding_ids(int index, ::uint32_t value) {
  _impl_.input_embedding_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.FillBlock.input_embedding_ids)
}
inline void FillBlock::add_input_embedding_ids(::uint32_t value) {
  _internal_add_input_embedding_ids(value);
  // @@protoc_insertion_point(field_add:l4m.FillBlock.input_embedding_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::input_embedding_ids() const {
  // @@protoc_insertion_point(field_list:l4m.FillBlock.input_embedding_ids)
  return _internal_input_embedding_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::mutable_input_embedding_ids() {
  // @@protoc_insertion_point(field_mutable_list:l4m.FillBlock.input_embedding_ids)
  return _internal_mutable_input_embedding_ids();
}

inline ::uint32_t FillBlock::_internal_input_embedding_ids(int index) const {
  return _impl_.input_embedding_ids_.Get(index);
}
inline void FillBlock::_internal_add_input_embedding_ids(::uint32_t value) { _impl_.input_embedding_ids_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::_internal_input_embedding_ids() const {
  return _impl_.input_embedding_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::_internal_mutable_input_embedding_ids() {
  return &_impl_.input_embedding_ids_;
}

// repeated uint32 output_embedding_ids = 4;
inline int FillBlock::_internal_output_embedding_ids_size() const {
  return _impl_.output_embedding_ids_.size();
}
inline int FillBlock::output_embedding_ids_size() const {
  return _internal_output_embedding_ids_size();
}
inline void FillBlock::clear_output_embedding_ids() {
  _impl_.output_embedding_ids_.Clear();
}
inline ::uint32_t FillBlock::output_embedding_ids(int index) const {
  // @@protoc_insertion_point(field_get:l4m.FillBlock.output_embedding_ids)
  return _internal_output_embedding_ids(index);
}
inline void FillBlock::set_output_embedding_ids(int index, ::uint32_t value) {
  _impl_.output_embedding_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.FillBlock.output_embedding_ids)
}
inline void FillBlock::add_output_embedding_ids(::uint32_t value) {
  _internal_add_output_embedding_ids(value);
  // @@protoc_insertion_point(field_add:l4m.FillBlock.output_embedding_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::output_embedding_ids() const {
  // @@protoc_insertion_point(field_list:l4m.FillBlock.output_embedding_ids)
  return _internal_output_embedding_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::mutable_output_embedding_ids() {
  // @@protoc_insertion_point(field_mutable_list:l4m.FillBlock.output_embedding_ids)
  return _internal_mutable_output_embedding_ids();
}

inline ::uint32_t FillBlock::_internal_output_embedding_ids(int index) const {
  return _impl_.output_embedding_ids_.Get(index);
}
inline void FillBlock::_internal_add_output_embedding_ids(::uint32_t value) { _impl_.output_embedding_ids_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& FillBlock::_internal_output_embedding_ids() const {
  return _impl_.output_embedding_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* FillBlock::_internal_mutable_output_embedding_ids() {
  return &_impl_.output_embedding_ids_;
}

// -------------------------------------------------------------------

// BatchFillBlock

// repeated .l4m.FillBlock items = 1;
inline int BatchFillBlock::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchFillBlock::items_size() const {
  return _internal_items_size();
}
inline void BatchFillBlock::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::FillBlock* BatchFillBlock::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchFillBlock.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::FillBlock >*
BatchFillBlock::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchFillBlock.items)
  return &_impl_.items_;
}
inline const ::l4m::FillBlock& BatchFillBlock::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::FillBlock& BatchFillBlock::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchFillBlock.items)
  return _internal_items(index);
}
inline ::l4m::FillBlock* BatchFillBlock::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::FillBlock* BatchFillBlock::add_items() {
  ::l4m::FillBlock* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchFillBlock.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::FillBlock >&
BatchFillBlock::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchFillBlock.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// MaskBlock

// uint32 block_id = 1;
inline void MaskBlock::clear_block_id() {
  _impl_.block_id_ = 0u;
}
inline ::uint32_t MaskBlock::block_id() const {
  // @@protoc_insertion_point(field_get:l4m.MaskBlock.block_id)
  return _internal_block_id();
}
inline void MaskBlock::set_block_id(::uint32_t value) {
  ;
  _internal_set_block_id(value);
  // @@protoc_insertion_point(field_set:l4m.MaskBlock.block_id)
}
inline ::uint32_t MaskBlock::_internal_block_id() const {
  return _impl_.block_id_;
}
inline void MaskBlock::_internal_set_block_id(::uint32_t value) {
  ;
  _impl_.block_id_ = value;
}

// repeated bool mask = 2;
inline int MaskBlock::_internal_mask_size() const {
  return _impl_.mask_.size();
}
inline int MaskBlock::mask_size() const {
  return _internal_mask_size();
}
inline void MaskBlock::clear_mask() {
  _impl_.mask_.Clear();
}
inline bool MaskBlock::mask(int index) const {
  // @@protoc_insertion_point(field_get:l4m.MaskBlock.mask)
  return _internal_mask(index);
}
inline void MaskBlock::set_mask(int index, bool value) {
  _impl_.mask_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.MaskBlock.mask)
}
inline void MaskBlock::add_mask(bool value) {
  _internal_add_mask(value);
  // @@protoc_insertion_point(field_add:l4m.MaskBlock.mask)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MaskBlock::mask() const {
  // @@protoc_insertion_point(field_list:l4m.MaskBlock.mask)
  return _internal_mask();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MaskBlock::mutable_mask() {
  // @@protoc_insertion_point(field_mutable_list:l4m.MaskBlock.mask)
  return _internal_mutable_mask();
}

inline bool MaskBlock::_internal_mask(int index) const {
  return _impl_.mask_.Get(index);
}
inline void MaskBlock::_internal_add_mask(bool value) { _impl_.mask_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MaskBlock::_internal_mask() const {
  return _impl_.mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MaskBlock::_internal_mutable_mask() {
  return &_impl_.mask_;
}

// -------------------------------------------------------------------

// BatchMaskBlock

// repeated .l4m.MaskBlock items = 1;
inline int BatchMaskBlock::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchMaskBlock::items_size() const {
  return _internal_items_size();
}
inline void BatchMaskBlock::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::MaskBlock* BatchMaskBlock::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchMaskBlock.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::MaskBlock >*
BatchMaskBlock::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchMaskBlock.items)
  return &_impl_.items_;
}
inline const ::l4m::MaskBlock& BatchMaskBlock::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::MaskBlock& BatchMaskBlock::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchMaskBlock.items)
  return _internal_items(index);
}
inline ::l4m::MaskBlock* BatchMaskBlock::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::MaskBlock* BatchMaskBlock::add_items() {
  ::l4m::MaskBlock* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchMaskBlock.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::MaskBlock >&
BatchMaskBlock::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchMaskBlock.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// CopyBlock

// uint32 source_block_id = 1;
inline void CopyBlock::clear_source_block_id() {
  _impl_.source_block_id_ = 0u;
}
inline ::uint32_t CopyBlock::source_block_id() const {
  // @@protoc_insertion_point(field_get:l4m.CopyBlock.source_block_id)
  return _internal_source_block_id();
}
inline void CopyBlock::set_source_block_id(::uint32_t value) {
  ;
  _internal_set_source_block_id(value);
  // @@protoc_insertion_point(field_set:l4m.CopyBlock.source_block_id)
}
inline ::uint32_t CopyBlock::_internal_source_block_id() const {
  return _impl_.source_block_id_;
}
inline void CopyBlock::_internal_set_source_block_id(::uint32_t value) {
  ;
  _impl_.source_block_id_ = value;
}

// uint32 destination_block_id = 2;
inline void CopyBlock::clear_destination_block_id() {
  _impl_.destination_block_id_ = 0u;
}
inline ::uint32_t CopyBlock::destination_block_id() const {
  // @@protoc_insertion_point(field_get:l4m.CopyBlock.destination_block_id)
  return _internal_destination_block_id();
}
inline void CopyBlock::set_destination_block_id(::uint32_t value) {
  ;
  _internal_set_destination_block_id(value);
  // @@protoc_insertion_point(field_set:l4m.CopyBlock.destination_block_id)
}
inline ::uint32_t CopyBlock::_internal_destination_block_id() const {
  return _impl_.destination_block_id_;
}
inline void CopyBlock::_internal_set_destination_block_id(::uint32_t value) {
  ;
  _impl_.destination_block_id_ = value;
}

// uint32 source_start = 3;
inline void CopyBlock::clear_source_start() {
  _impl_.source_start_ = 0u;
}
inline ::uint32_t CopyBlock::source_start() const {
  // @@protoc_insertion_point(field_get:l4m.CopyBlock.source_start)
  return _internal_source_start();
}
inline void CopyBlock::set_source_start(::uint32_t value) {
  ;
  _internal_set_source_start(value);
  // @@protoc_insertion_point(field_set:l4m.CopyBlock.source_start)
}
inline ::uint32_t CopyBlock::_internal_source_start() const {
  return _impl_.source_start_;
}
inline void CopyBlock::_internal_set_source_start(::uint32_t value) {
  ;
  _impl_.source_start_ = value;
}

// uint32 destination_start = 4;
inline void CopyBlock::clear_destination_start() {
  _impl_.destination_start_ = 0u;
}
inline ::uint32_t CopyBlock::destination_start() const {
  // @@protoc_insertion_point(field_get:l4m.CopyBlock.destination_start)
  return _internal_destination_start();
}
inline void CopyBlock::set_destination_start(::uint32_t value) {
  ;
  _internal_set_destination_start(value);
  // @@protoc_insertion_point(field_set:l4m.CopyBlock.destination_start)
}
inline ::uint32_t CopyBlock::_internal_destination_start() const {
  return _impl_.destination_start_;
}
inline void CopyBlock::_internal_set_destination_start(::uint32_t value) {
  ;
  _impl_.destination_start_ = value;
}

// uint32 length = 5;
inline void CopyBlock::clear_length() {
  _impl_.length_ = 0u;
}
inline ::uint32_t CopyBlock::length() const {
  // @@protoc_insertion_point(field_get:l4m.CopyBlock.length)
  return _internal_length();
}
inline void CopyBlock::set_length(::uint32_t value) {
  ;
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:l4m.CopyBlock.length)
}
inline ::uint32_t CopyBlock::_internal_length() const {
  return _impl_.length_;
}
inline void CopyBlock::_internal_set_length(::uint32_t value) {
  ;
  _impl_.length_ = value;
}

// -------------------------------------------------------------------

// BatchCopyBlock

// repeated .l4m.CopyBlock items = 1;
inline int BatchCopyBlock::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchCopyBlock::items_size() const {
  return _internal_items_size();
}
inline void BatchCopyBlock::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::CopyBlock* BatchCopyBlock::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchCopyBlock.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::CopyBlock >*
BatchCopyBlock::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchCopyBlock.items)
  return &_impl_.items_;
}
inline const ::l4m::CopyBlock& BatchCopyBlock::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::CopyBlock& BatchCopyBlock::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchCopyBlock.items)
  return _internal_items(index);
}
inline ::l4m::CopyBlock* BatchCopyBlock::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::CopyBlock* BatchCopyBlock::add_items() {
  ::l4m::CopyBlock* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchCopyBlock.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::CopyBlock >&
BatchCopyBlock::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchCopyBlock.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// DecodeTokenDistribution

// uint32 embedding_id = 1;
inline void DecodeTokenDistribution::clear_embedding_id() {
  _impl_.embedding_id_ = 0u;
}
inline ::uint32_t DecodeTokenDistribution::embedding_id() const {
  // @@protoc_insertion_point(field_get:l4m.DecodeTokenDistribution.embedding_id)
  return _internal_embedding_id();
}
inline void DecodeTokenDistribution::set_embedding_id(::uint32_t value) {
  ;
  _internal_set_embedding_id(value);
  // @@protoc_insertion_point(field_set:l4m.DecodeTokenDistribution.embedding_id)
}
inline ::uint32_t DecodeTokenDistribution::_internal_embedding_id() const {
  return _impl_.embedding_id_;
}
inline void DecodeTokenDistribution::_internal_set_embedding_id(::uint32_t value) {
  ;
  _impl_.embedding_id_ = value;
}

// uint32 distribution_id = 2;
inline void DecodeTokenDistribution::clear_distribution_id() {
  _impl_.distribution_id_ = 0u;
}
inline ::uint32_t DecodeTokenDistribution::distribution_id() const {
  // @@protoc_insertion_point(field_get:l4m.DecodeTokenDistribution.distribution_id)
  return _internal_distribution_id();
}
inline void DecodeTokenDistribution::set_distribution_id(::uint32_t value) {
  ;
  _internal_set_distribution_id(value);
  // @@protoc_insertion_point(field_set:l4m.DecodeTokenDistribution.distribution_id)
}
inline ::uint32_t DecodeTokenDistribution::_internal_distribution_id() const {
  return _impl_.distribution_id_;
}
inline void DecodeTokenDistribution::_internal_set_distribution_id(::uint32_t value) {
  ;
  _impl_.distribution_id_ = value;
}

// -------------------------------------------------------------------

// BatchDecodeTokenDistribution

// repeated .l4m.DecodeTokenDistribution items = 1;
inline int BatchDecodeTokenDistribution::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchDecodeTokenDistribution::items_size() const {
  return _internal_items_size();
}
inline void BatchDecodeTokenDistribution::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::DecodeTokenDistribution* BatchDecodeTokenDistribution::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchDecodeTokenDistribution.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::DecodeTokenDistribution >*
BatchDecodeTokenDistribution::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchDecodeTokenDistribution.items)
  return &_impl_.items_;
}
inline const ::l4m::DecodeTokenDistribution& BatchDecodeTokenDistribution::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::DecodeTokenDistribution& BatchDecodeTokenDistribution::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchDecodeTokenDistribution.items)
  return _internal_items(index);
}
inline ::l4m::DecodeTokenDistribution* BatchDecodeTokenDistribution::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::DecodeTokenDistribution* BatchDecodeTokenDistribution::add_items() {
  ::l4m::DecodeTokenDistribution* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchDecodeTokenDistribution.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::DecodeTokenDistribution >&
BatchDecodeTokenDistribution::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchDecodeTokenDistribution.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// SampleTopKRequest

// uint32 distribution_id = 1;
inline void SampleTopKRequest::clear_distribution_id() {
  _impl_.distribution_id_ = 0u;
}
inline ::uint32_t SampleTopKRequest::distribution_id() const {
  // @@protoc_insertion_point(field_get:l4m.SampleTopKRequest.distribution_id)
  return _internal_distribution_id();
}
inline void SampleTopKRequest::set_distribution_id(::uint32_t value) {
  ;
  _internal_set_distribution_id(value);
  // @@protoc_insertion_point(field_set:l4m.SampleTopKRequest.distribution_id)
}
inline ::uint32_t SampleTopKRequest::_internal_distribution_id() const {
  return _impl_.distribution_id_;
}
inline void SampleTopKRequest::_internal_set_distribution_id(::uint32_t value) {
  ;
  _impl_.distribution_id_ = value;
}

// uint32 k = 2;
inline void SampleTopKRequest::clear_k() {
  _impl_.k_ = 0u;
}
inline ::uint32_t SampleTopKRequest::k() const {
  // @@protoc_insertion_point(field_get:l4m.SampleTopKRequest.k)
  return _internal_k();
}
inline void SampleTopKRequest::set_k(::uint32_t value) {
  ;
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:l4m.SampleTopKRequest.k)
}
inline ::uint32_t SampleTopKRequest::_internal_k() const {
  return _impl_.k_;
}
inline void SampleTopKRequest::_internal_set_k(::uint32_t value) {
  ;
  _impl_.k_ = value;
}

// -------------------------------------------------------------------

// BatchSampleTopKRequest

// repeated .l4m.SampleTopKRequest items = 1;
inline int BatchSampleTopKRequest::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchSampleTopKRequest::items_size() const {
  return _internal_items_size();
}
inline void BatchSampleTopKRequest::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::SampleTopKRequest* BatchSampleTopKRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchSampleTopKRequest.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKRequest >*
BatchSampleTopKRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchSampleTopKRequest.items)
  return &_impl_.items_;
}
inline const ::l4m::SampleTopKRequest& BatchSampleTopKRequest::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::SampleTopKRequest& BatchSampleTopKRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchSampleTopKRequest.items)
  return _internal_items(index);
}
inline ::l4m::SampleTopKRequest* BatchSampleTopKRequest::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::SampleTopKRequest* BatchSampleTopKRequest::add_items() {
  ::l4m::SampleTopKRequest* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchSampleTopKRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKRequest >&
BatchSampleTopKRequest::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchSampleTopKRequest.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// SampleTopKResponse

// repeated uint32 token_ids = 1;
inline int SampleTopKResponse::_internal_token_ids_size() const {
  return _impl_.token_ids_.size();
}
inline int SampleTopKResponse::token_ids_size() const {
  return _internal_token_ids_size();
}
inline void SampleTopKResponse::clear_token_ids() {
  _impl_.token_ids_.Clear();
}
inline ::uint32_t SampleTopKResponse::token_ids(int index) const {
  // @@protoc_insertion_point(field_get:l4m.SampleTopKResponse.token_ids)
  return _internal_token_ids(index);
}
inline void SampleTopKResponse::set_token_ids(int index, ::uint32_t value) {
  _impl_.token_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.SampleTopKResponse.token_ids)
}
inline void SampleTopKResponse::add_token_ids(::uint32_t value) {
  _internal_add_token_ids(value);
  // @@protoc_insertion_point(field_add:l4m.SampleTopKResponse.token_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& SampleTopKResponse::token_ids() const {
  // @@protoc_insertion_point(field_list:l4m.SampleTopKResponse.token_ids)
  return _internal_token_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* SampleTopKResponse::mutable_token_ids() {
  // @@protoc_insertion_point(field_mutable_list:l4m.SampleTopKResponse.token_ids)
  return _internal_mutable_token_ids();
}

inline ::uint32_t SampleTopKResponse::_internal_token_ids(int index) const {
  return _impl_.token_ids_.Get(index);
}
inline void SampleTopKResponse::_internal_add_token_ids(::uint32_t value) { _impl_.token_ids_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& SampleTopKResponse::_internal_token_ids() const {
  return _impl_.token_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* SampleTopKResponse::_internal_mutable_token_ids() {
  return &_impl_.token_ids_;
}

// repeated float probabilities = 2;
inline int SampleTopKResponse::_internal_probabilities_size() const {
  return _impl_.probabilities_.size();
}
inline int SampleTopKResponse::probabilities_size() const {
  return _internal_probabilities_size();
}
inline void SampleTopKResponse::clear_probabilities() {
  _impl_.probabilities_.Clear();
}
inline float SampleTopKResponse::probabilities(int index) const {
  // @@protoc_insertion_point(field_get:l4m.SampleTopKResponse.probabilities)
  return _internal_probabilities(index);
}
inline void SampleTopKResponse::set_probabilities(int index, float value) {
  _impl_.probabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:l4m.SampleTopKResponse.probabilities)
}
inline void SampleTopKResponse::add_probabilities(float value) {
  _internal_add_probabilities(value);
  // @@protoc_insertion_point(field_add:l4m.SampleTopKResponse.probabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& SampleTopKResponse::probabilities() const {
  // @@protoc_insertion_point(field_list:l4m.SampleTopKResponse.probabilities)
  return _internal_probabilities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* SampleTopKResponse::mutable_probabilities() {
  // @@protoc_insertion_point(field_mutable_list:l4m.SampleTopKResponse.probabilities)
  return _internal_mutable_probabilities();
}

inline float SampleTopKResponse::_internal_probabilities(int index) const {
  return _impl_.probabilities_.Get(index);
}
inline void SampleTopKResponse::_internal_add_probabilities(float value) { _impl_.probabilities_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& SampleTopKResponse::_internal_probabilities() const {
  return _impl_.probabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* SampleTopKResponse::_internal_mutable_probabilities() {
  return &_impl_.probabilities_;
}

// -------------------------------------------------------------------

// BatchSampleTopKResponse

// repeated .l4m.SampleTopKResponse items = 1;
inline int BatchSampleTopKResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BatchSampleTopKResponse::items_size() const {
  return _internal_items_size();
}
inline void BatchSampleTopKResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::l4m::SampleTopKResponse* BatchSampleTopKResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:l4m.BatchSampleTopKResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKResponse >*
BatchSampleTopKResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:l4m.BatchSampleTopKResponse.items)
  return &_impl_.items_;
}
inline const ::l4m::SampleTopKResponse& BatchSampleTopKResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::l4m::SampleTopKResponse& BatchSampleTopKResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:l4m.BatchSampleTopKResponse.items)
  return _internal_items(index);
}
inline ::l4m::SampleTopKResponse* BatchSampleTopKResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::l4m::SampleTopKResponse* BatchSampleTopKResponse::add_items() {
  ::l4m::SampleTopKResponse* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:l4m.BatchSampleTopKResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::l4m::SampleTopKResponse >&
BatchSampleTopKResponse::items() const {
  // @@protoc_insertion_point(field_list:l4m.BatchSampleTopKResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// GetInfoRequest

// -------------------------------------------------------------------

// GetInfoResponse

// string version = 1;
inline void GetInfoResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetInfoResponse::version() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInfoResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.version)
}
inline std::string* GetInfoResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:l4m.GetInfoResponse.version)
  return _s;
}
inline const std::string& GetInfoResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetInfoResponse::_internal_set_version(const std::string& value) {

  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInfoResponse::_internal_mutable_version() {

  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInfoResponse::release_version() {
  // @@protoc_insertion_point(field_release:l4m.GetInfoResponse.version)
  return _impl_.version_.Release();
}
inline void GetInfoResponse::set_allocated_version(std::string* version) {
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:l4m.GetInfoResponse.version)
}

// string model_name = 2;
inline void GetInfoResponse::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& GetInfoResponse::model_name() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInfoResponse::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.model_name)
}
inline std::string* GetInfoResponse::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:l4m.GetInfoResponse.model_name)
  return _s;
}
inline const std::string& GetInfoResponse::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void GetInfoResponse::_internal_set_model_name(const std::string& value) {

  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInfoResponse::_internal_mutable_model_name() {

  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInfoResponse::release_model_name() {
  // @@protoc_insertion_point(field_release:l4m.GetInfoResponse.model_name)
  return _impl_.model_name_.Release();
}
inline void GetInfoResponse::set_allocated_model_name(std::string* model_name) {
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:l4m.GetInfoResponse.model_name)
}

// uint32 block_size = 3;
inline void GetInfoResponse::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline ::uint32_t GetInfoResponse::block_size() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.block_size)
  return _internal_block_size();
}
inline void GetInfoResponse::set_block_size(::uint32_t value) {
  ;
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.block_size)
}
inline ::uint32_t GetInfoResponse::_internal_block_size() const {
  return _impl_.block_size_;
}
inline void GetInfoResponse::_internal_set_block_size(::uint32_t value) {
  ;
  _impl_.block_size_ = value;
}

// uint32 num_available_blocks = 4;
inline void GetInfoResponse::clear_num_available_blocks() {
  _impl_.num_available_blocks_ = 0u;
}
inline ::uint32_t GetInfoResponse::num_available_blocks() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.num_available_blocks)
  return _internal_num_available_blocks();
}
inline void GetInfoResponse::set_num_available_blocks(::uint32_t value) {
  ;
  _internal_set_num_available_blocks(value);
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.num_available_blocks)
}
inline ::uint32_t GetInfoResponse::_internal_num_available_blocks() const {
  return _impl_.num_available_blocks_;
}
inline void GetInfoResponse::_internal_set_num_available_blocks(::uint32_t value) {
  ;
  _impl_.num_available_blocks_ = value;
}

// uint32 num_available_embeddings = 5;
inline void GetInfoResponse::clear_num_available_embeddings() {
  _impl_.num_available_embeddings_ = 0u;
}
inline ::uint32_t GetInfoResponse::num_available_embeddings() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.num_available_embeddings)
  return _internal_num_available_embeddings();
}
inline void GetInfoResponse::set_num_available_embeddings(::uint32_t value) {
  ;
  _internal_set_num_available_embeddings(value);
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.num_available_embeddings)
}
inline ::uint32_t GetInfoResponse::_internal_num_available_embeddings() const {
  return _impl_.num_available_embeddings_;
}
inline void GetInfoResponse::_internal_set_num_available_embeddings(::uint32_t value) {
  ;
  _impl_.num_available_embeddings_ = value;
}

// uint32 num_available_distributions = 6;
inline void GetInfoResponse::clear_num_available_distributions() {
  _impl_.num_available_distributions_ = 0u;
}
inline ::uint32_t GetInfoResponse::num_available_distributions() const {
  // @@protoc_insertion_point(field_get:l4m.GetInfoResponse.num_available_distributions)
  return _internal_num_available_distributions();
}
inline void GetInfoResponse::set_num_available_distributions(::uint32_t value) {
  ;
  _internal_set_num_available_distributions(value);
  // @@protoc_insertion_point(field_set:l4m.GetInfoResponse.num_available_distributions)
}
inline ::uint32_t GetInfoResponse::_internal_num_available_distributions() const {
  return _impl_.num_available_distributions_;
}
inline void GetInfoResponse::_internal_set_num_available_distributions(::uint32_t value) {
  ;
  _impl_.num_available_distributions_ = value;
}

// -------------------------------------------------------------------

// Request

// uint32 correlation_id = 1;
inline void Request::clear_correlation_id() {
  _impl_.correlation_id_ = 0u;
}
inline ::uint32_t Request::correlation_id() const {
  // @@protoc_insertion_point(field_get:l4m.Request.correlation_id)
  return _internal_correlation_id();
}
inline void Request::set_correlation_id(::uint32_t value) {
  ;
  _internal_set_correlation_id(value);
  // @@protoc_insertion_point(field_set:l4m.Request.correlation_id)
}
inline ::uint32_t Request::_internal_correlation_id() const {
  return _impl_.correlation_id_;
}
inline void Request::_internal_set_correlation_id(::uint32_t value) {
  ;
  _impl_.correlation_id_ = value;
}

// .l4m.BatchAllocate allocate = 2;
inline bool Request::has_allocate() const {
  return command_case() == kAllocate;
}
inline bool Request::_internal_has_allocate() const {
  return command_case() == kAllocate;
}
inline void Request::set_has_allocate() {
  _impl_._oneof_case_[0] = kAllocate;
}
inline void Request::clear_allocate() {
  if (command_case() == kAllocate) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.allocate_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchAllocate* Request::release_allocate() {
  // @@protoc_insertion_point(field_release:l4m.Request.allocate)
  if (command_case() == kAllocate) {
    clear_has_command();
    ::l4m::BatchAllocate* temp = _impl_.command_.allocate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.allocate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchAllocate& Request::_internal_allocate() const {
  return command_case() == kAllocate
      ? *_impl_.command_.allocate_
      : reinterpret_cast< ::l4m::BatchAllocate&>(::l4m::_BatchAllocate_default_instance_);
}
inline const ::l4m::BatchAllocate& Request::allocate() const {
  // @@protoc_insertion_point(field_get:l4m.Request.allocate)
  return _internal_allocate();
}
inline ::l4m::BatchAllocate* Request::unsafe_arena_release_allocate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.allocate)
  if (command_case() == kAllocate) {
    clear_has_command();
    ::l4m::BatchAllocate* temp = _impl_.command_.allocate_;
    _impl_.command_.allocate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_allocate(::l4m::BatchAllocate* allocate) {
  clear_command();
  if (allocate) {
    set_has_allocate();
    _impl_.command_.allocate_ = allocate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.allocate)
}
inline ::l4m::BatchAllocate* Request::_internal_mutable_allocate() {
  if (command_case() != kAllocate) {
    clear_command();
    set_has_allocate();
    _impl_.command_.allocate_ = CreateMaybeMessage< ::l4m::BatchAllocate >(GetArenaForAllocation());
  }
  return _impl_.command_.allocate_;
}
inline ::l4m::BatchAllocate* Request::mutable_allocate() {
  ::l4m::BatchAllocate* _msg = _internal_mutable_allocate();
  // @@protoc_insertion_point(field_mutable:l4m.Request.allocate)
  return _msg;
}

// .l4m.BatchDeallocate deallocate = 3;
inline bool Request::has_deallocate() const {
  return command_case() == kDeallocate;
}
inline bool Request::_internal_has_deallocate() const {
  return command_case() == kDeallocate;
}
inline void Request::set_has_deallocate() {
  _impl_._oneof_case_[0] = kDeallocate;
}
inline void Request::clear_deallocate() {
  if (command_case() == kDeallocate) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.deallocate_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchDeallocate* Request::release_deallocate() {
  // @@protoc_insertion_point(field_release:l4m.Request.deallocate)
  if (command_case() == kDeallocate) {
    clear_has_command();
    ::l4m::BatchDeallocate* temp = _impl_.command_.deallocate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.deallocate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchDeallocate& Request::_internal_deallocate() const {
  return command_case() == kDeallocate
      ? *_impl_.command_.deallocate_
      : reinterpret_cast< ::l4m::BatchDeallocate&>(::l4m::_BatchDeallocate_default_instance_);
}
inline const ::l4m::BatchDeallocate& Request::deallocate() const {
  // @@protoc_insertion_point(field_get:l4m.Request.deallocate)
  return _internal_deallocate();
}
inline ::l4m::BatchDeallocate* Request::unsafe_arena_release_deallocate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.deallocate)
  if (command_case() == kDeallocate) {
    clear_has_command();
    ::l4m::BatchDeallocate* temp = _impl_.command_.deallocate_;
    _impl_.command_.deallocate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_deallocate(::l4m::BatchDeallocate* deallocate) {
  clear_command();
  if (deallocate) {
    set_has_deallocate();
    _impl_.command_.deallocate_ = deallocate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.deallocate)
}
inline ::l4m::BatchDeallocate* Request::_internal_mutable_deallocate() {
  if (command_case() != kDeallocate) {
    clear_command();
    set_has_deallocate();
    _impl_.command_.deallocate_ = CreateMaybeMessage< ::l4m::BatchDeallocate >(GetArenaForAllocation());
  }
  return _impl_.command_.deallocate_;
}
inline ::l4m::BatchDeallocate* Request::mutable_deallocate() {
  ::l4m::BatchDeallocate* _msg = _internal_mutable_deallocate();
  // @@protoc_insertion_point(field_mutable:l4m.Request.deallocate)
  return _msg;
}

// .l4m.BatchEmbedText embed_text = 4;
inline bool Request::has_embed_text() const {
  return command_case() == kEmbedText;
}
inline bool Request::_internal_has_embed_text() const {
  return command_case() == kEmbedText;
}
inline void Request::set_has_embed_text() {
  _impl_._oneof_case_[0] = kEmbedText;
}
inline void Request::clear_embed_text() {
  if (command_case() == kEmbedText) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.embed_text_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchEmbedText* Request::release_embed_text() {
  // @@protoc_insertion_point(field_release:l4m.Request.embed_text)
  if (command_case() == kEmbedText) {
    clear_has_command();
    ::l4m::BatchEmbedText* temp = _impl_.command_.embed_text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.embed_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchEmbedText& Request::_internal_embed_text() const {
  return command_case() == kEmbedText
      ? *_impl_.command_.embed_text_
      : reinterpret_cast< ::l4m::BatchEmbedText&>(::l4m::_BatchEmbedText_default_instance_);
}
inline const ::l4m::BatchEmbedText& Request::embed_text() const {
  // @@protoc_insertion_point(field_get:l4m.Request.embed_text)
  return _internal_embed_text();
}
inline ::l4m::BatchEmbedText* Request::unsafe_arena_release_embed_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.embed_text)
  if (command_case() == kEmbedText) {
    clear_has_command();
    ::l4m::BatchEmbedText* temp = _impl_.command_.embed_text_;
    _impl_.command_.embed_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_embed_text(::l4m::BatchEmbedText* embed_text) {
  clear_command();
  if (embed_text) {
    set_has_embed_text();
    _impl_.command_.embed_text_ = embed_text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.embed_text)
}
inline ::l4m::BatchEmbedText* Request::_internal_mutable_embed_text() {
  if (command_case() != kEmbedText) {
    clear_command();
    set_has_embed_text();
    _impl_.command_.embed_text_ = CreateMaybeMessage< ::l4m::BatchEmbedText >(GetArenaForAllocation());
  }
  return _impl_.command_.embed_text_;
}
inline ::l4m::BatchEmbedText* Request::mutable_embed_text() {
  ::l4m::BatchEmbedText* _msg = _internal_mutable_embed_text();
  // @@protoc_insertion_point(field_mutable:l4m.Request.embed_text)
  return _msg;
}

// .l4m.BatchFillBlock fill_block = 5;
inline bool Request::has_fill_block() const {
  return command_case() == kFillBlock;
}
inline bool Request::_internal_has_fill_block() const {
  return command_case() == kFillBlock;
}
inline void Request::set_has_fill_block() {
  _impl_._oneof_case_[0] = kFillBlock;
}
inline void Request::clear_fill_block() {
  if (command_case() == kFillBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.fill_block_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchFillBlock* Request::release_fill_block() {
  // @@protoc_insertion_point(field_release:l4m.Request.fill_block)
  if (command_case() == kFillBlock) {
    clear_has_command();
    ::l4m::BatchFillBlock* temp = _impl_.command_.fill_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.fill_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchFillBlock& Request::_internal_fill_block() const {
  return command_case() == kFillBlock
      ? *_impl_.command_.fill_block_
      : reinterpret_cast< ::l4m::BatchFillBlock&>(::l4m::_BatchFillBlock_default_instance_);
}
inline const ::l4m::BatchFillBlock& Request::fill_block() const {
  // @@protoc_insertion_point(field_get:l4m.Request.fill_block)
  return _internal_fill_block();
}
inline ::l4m::BatchFillBlock* Request::unsafe_arena_release_fill_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.fill_block)
  if (command_case() == kFillBlock) {
    clear_has_command();
    ::l4m::BatchFillBlock* temp = _impl_.command_.fill_block_;
    _impl_.command_.fill_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_fill_block(::l4m::BatchFillBlock* fill_block) {
  clear_command();
  if (fill_block) {
    set_has_fill_block();
    _impl_.command_.fill_block_ = fill_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.fill_block)
}
inline ::l4m::BatchFillBlock* Request::_internal_mutable_fill_block() {
  if (command_case() != kFillBlock) {
    clear_command();
    set_has_fill_block();
    _impl_.command_.fill_block_ = CreateMaybeMessage< ::l4m::BatchFillBlock >(GetArenaForAllocation());
  }
  return _impl_.command_.fill_block_;
}
inline ::l4m::BatchFillBlock* Request::mutable_fill_block() {
  ::l4m::BatchFillBlock* _msg = _internal_mutable_fill_block();
  // @@protoc_insertion_point(field_mutable:l4m.Request.fill_block)
  return _msg;
}

// .l4m.BatchMaskBlock mask_block = 6;
inline bool Request::has_mask_block() const {
  return command_case() == kMaskBlock;
}
inline bool Request::_internal_has_mask_block() const {
  return command_case() == kMaskBlock;
}
inline void Request::set_has_mask_block() {
  _impl_._oneof_case_[0] = kMaskBlock;
}
inline void Request::clear_mask_block() {
  if (command_case() == kMaskBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.mask_block_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchMaskBlock* Request::release_mask_block() {
  // @@protoc_insertion_point(field_release:l4m.Request.mask_block)
  if (command_case() == kMaskBlock) {
    clear_has_command();
    ::l4m::BatchMaskBlock* temp = _impl_.command_.mask_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.mask_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchMaskBlock& Request::_internal_mask_block() const {
  return command_case() == kMaskBlock
      ? *_impl_.command_.mask_block_
      : reinterpret_cast< ::l4m::BatchMaskBlock&>(::l4m::_BatchMaskBlock_default_instance_);
}
inline const ::l4m::BatchMaskBlock& Request::mask_block() const {
  // @@protoc_insertion_point(field_get:l4m.Request.mask_block)
  return _internal_mask_block();
}
inline ::l4m::BatchMaskBlock* Request::unsafe_arena_release_mask_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.mask_block)
  if (command_case() == kMaskBlock) {
    clear_has_command();
    ::l4m::BatchMaskBlock* temp = _impl_.command_.mask_block_;
    _impl_.command_.mask_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_mask_block(::l4m::BatchMaskBlock* mask_block) {
  clear_command();
  if (mask_block) {
    set_has_mask_block();
    _impl_.command_.mask_block_ = mask_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.mask_block)
}
inline ::l4m::BatchMaskBlock* Request::_internal_mutable_mask_block() {
  if (command_case() != kMaskBlock) {
    clear_command();
    set_has_mask_block();
    _impl_.command_.mask_block_ = CreateMaybeMessage< ::l4m::BatchMaskBlock >(GetArenaForAllocation());
  }
  return _impl_.command_.mask_block_;
}
inline ::l4m::BatchMaskBlock* Request::mutable_mask_block() {
  ::l4m::BatchMaskBlock* _msg = _internal_mutable_mask_block();
  // @@protoc_insertion_point(field_mutable:l4m.Request.mask_block)
  return _msg;
}

// .l4m.BatchCopyBlock copy_block = 7;
inline bool Request::has_copy_block() const {
  return command_case() == kCopyBlock;
}
inline bool Request::_internal_has_copy_block() const {
  return command_case() == kCopyBlock;
}
inline void Request::set_has_copy_block() {
  _impl_._oneof_case_[0] = kCopyBlock;
}
inline void Request::clear_copy_block() {
  if (command_case() == kCopyBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.copy_block_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchCopyBlock* Request::release_copy_block() {
  // @@protoc_insertion_point(field_release:l4m.Request.copy_block)
  if (command_case() == kCopyBlock) {
    clear_has_command();
    ::l4m::BatchCopyBlock* temp = _impl_.command_.copy_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.copy_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchCopyBlock& Request::_internal_copy_block() const {
  return command_case() == kCopyBlock
      ? *_impl_.command_.copy_block_
      : reinterpret_cast< ::l4m::BatchCopyBlock&>(::l4m::_BatchCopyBlock_default_instance_);
}
inline const ::l4m::BatchCopyBlock& Request::copy_block() const {
  // @@protoc_insertion_point(field_get:l4m.Request.copy_block)
  return _internal_copy_block();
}
inline ::l4m::BatchCopyBlock* Request::unsafe_arena_release_copy_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.copy_block)
  if (command_case() == kCopyBlock) {
    clear_has_command();
    ::l4m::BatchCopyBlock* temp = _impl_.command_.copy_block_;
    _impl_.command_.copy_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_copy_block(::l4m::BatchCopyBlock* copy_block) {
  clear_command();
  if (copy_block) {
    set_has_copy_block();
    _impl_.command_.copy_block_ = copy_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.copy_block)
}
inline ::l4m::BatchCopyBlock* Request::_internal_mutable_copy_block() {
  if (command_case() != kCopyBlock) {
    clear_command();
    set_has_copy_block();
    _impl_.command_.copy_block_ = CreateMaybeMessage< ::l4m::BatchCopyBlock >(GetArenaForAllocation());
  }
  return _impl_.command_.copy_block_;
}
inline ::l4m::BatchCopyBlock* Request::mutable_copy_block() {
  ::l4m::BatchCopyBlock* _msg = _internal_mutable_copy_block();
  // @@protoc_insertion_point(field_mutable:l4m.Request.copy_block)
  return _msg;
}

// .l4m.BatchDecodeTokenDistribution decode_token_distribution = 8;
inline bool Request::has_decode_token_distribution() const {
  return command_case() == kDecodeTokenDistribution;
}
inline bool Request::_internal_has_decode_token_distribution() const {
  return command_case() == kDecodeTokenDistribution;
}
inline void Request::set_has_decode_token_distribution() {
  _impl_._oneof_case_[0] = kDecodeTokenDistribution;
}
inline void Request::clear_decode_token_distribution() {
  if (command_case() == kDecodeTokenDistribution) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.decode_token_distribution_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchDecodeTokenDistribution* Request::release_decode_token_distribution() {
  // @@protoc_insertion_point(field_release:l4m.Request.decode_token_distribution)
  if (command_case() == kDecodeTokenDistribution) {
    clear_has_command();
    ::l4m::BatchDecodeTokenDistribution* temp = _impl_.command_.decode_token_distribution_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.decode_token_distribution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchDecodeTokenDistribution& Request::_internal_decode_token_distribution() const {
  return command_case() == kDecodeTokenDistribution
      ? *_impl_.command_.decode_token_distribution_
      : reinterpret_cast< ::l4m::BatchDecodeTokenDistribution&>(::l4m::_BatchDecodeTokenDistribution_default_instance_);
}
inline const ::l4m::BatchDecodeTokenDistribution& Request::decode_token_distribution() const {
  // @@protoc_insertion_point(field_get:l4m.Request.decode_token_distribution)
  return _internal_decode_token_distribution();
}
inline ::l4m::BatchDecodeTokenDistribution* Request::unsafe_arena_release_decode_token_distribution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.decode_token_distribution)
  if (command_case() == kDecodeTokenDistribution) {
    clear_has_command();
    ::l4m::BatchDecodeTokenDistribution* temp = _impl_.command_.decode_token_distribution_;
    _impl_.command_.decode_token_distribution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_decode_token_distribution(::l4m::BatchDecodeTokenDistribution* decode_token_distribution) {
  clear_command();
  if (decode_token_distribution) {
    set_has_decode_token_distribution();
    _impl_.command_.decode_token_distribution_ = decode_token_distribution;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.decode_token_distribution)
}
inline ::l4m::BatchDecodeTokenDistribution* Request::_internal_mutable_decode_token_distribution() {
  if (command_case() != kDecodeTokenDistribution) {
    clear_command();
    set_has_decode_token_distribution();
    _impl_.command_.decode_token_distribution_ = CreateMaybeMessage< ::l4m::BatchDecodeTokenDistribution >(GetArenaForAllocation());
  }
  return _impl_.command_.decode_token_distribution_;
}
inline ::l4m::BatchDecodeTokenDistribution* Request::mutable_decode_token_distribution() {
  ::l4m::BatchDecodeTokenDistribution* _msg = _internal_mutable_decode_token_distribution();
  // @@protoc_insertion_point(field_mutable:l4m.Request.decode_token_distribution)
  return _msg;
}

// .l4m.BatchSampleTopKRequest sample_top_k_request = 9;
inline bool Request::has_sample_top_k_request() const {
  return command_case() == kSampleTopKRequest;
}
inline bool Request::_internal_has_sample_top_k_request() const {
  return command_case() == kSampleTopKRequest;
}
inline void Request::set_has_sample_top_k_request() {
  _impl_._oneof_case_[0] = kSampleTopKRequest;
}
inline void Request::clear_sample_top_k_request() {
  if (command_case() == kSampleTopKRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.sample_top_k_request_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchSampleTopKRequest* Request::release_sample_top_k_request() {
  // @@protoc_insertion_point(field_release:l4m.Request.sample_top_k_request)
  if (command_case() == kSampleTopKRequest) {
    clear_has_command();
    ::l4m::BatchSampleTopKRequest* temp = _impl_.command_.sample_top_k_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.sample_top_k_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchSampleTopKRequest& Request::_internal_sample_top_k_request() const {
  return command_case() == kSampleTopKRequest
      ? *_impl_.command_.sample_top_k_request_
      : reinterpret_cast< ::l4m::BatchSampleTopKRequest&>(::l4m::_BatchSampleTopKRequest_default_instance_);
}
inline const ::l4m::BatchSampleTopKRequest& Request::sample_top_k_request() const {
  // @@protoc_insertion_point(field_get:l4m.Request.sample_top_k_request)
  return _internal_sample_top_k_request();
}
inline ::l4m::BatchSampleTopKRequest* Request::unsafe_arena_release_sample_top_k_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.sample_top_k_request)
  if (command_case() == kSampleTopKRequest) {
    clear_has_command();
    ::l4m::BatchSampleTopKRequest* temp = _impl_.command_.sample_top_k_request_;
    _impl_.command_.sample_top_k_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_sample_top_k_request(::l4m::BatchSampleTopKRequest* sample_top_k_request) {
  clear_command();
  if (sample_top_k_request) {
    set_has_sample_top_k_request();
    _impl_.command_.sample_top_k_request_ = sample_top_k_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.sample_top_k_request)
}
inline ::l4m::BatchSampleTopKRequest* Request::_internal_mutable_sample_top_k_request() {
  if (command_case() != kSampleTopKRequest) {
    clear_command();
    set_has_sample_top_k_request();
    _impl_.command_.sample_top_k_request_ = CreateMaybeMessage< ::l4m::BatchSampleTopKRequest >(GetArenaForAllocation());
  }
  return _impl_.command_.sample_top_k_request_;
}
inline ::l4m::BatchSampleTopKRequest* Request::mutable_sample_top_k_request() {
  ::l4m::BatchSampleTopKRequest* _msg = _internal_mutable_sample_top_k_request();
  // @@protoc_insertion_point(field_mutable:l4m.Request.sample_top_k_request)
  return _msg;
}

// .l4m.GetInfoRequest get_info = 10;
inline bool Request::has_get_info() const {
  return command_case() == kGetInfo;
}
inline bool Request::_internal_has_get_info() const {
  return command_case() == kGetInfo;
}
inline void Request::set_has_get_info() {
  _impl_._oneof_case_[0] = kGetInfo;
}
inline void Request::clear_get_info() {
  if (command_case() == kGetInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.get_info_;
    }
    clear_has_command();
  }
}
inline ::l4m::GetInfoRequest* Request::release_get_info() {
  // @@protoc_insertion_point(field_release:l4m.Request.get_info)
  if (command_case() == kGetInfo) {
    clear_has_command();
    ::l4m::GetInfoRequest* temp = _impl_.command_.get_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.get_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::GetInfoRequest& Request::_internal_get_info() const {
  return command_case() == kGetInfo
      ? *_impl_.command_.get_info_
      : reinterpret_cast< ::l4m::GetInfoRequest&>(::l4m::_GetInfoRequest_default_instance_);
}
inline const ::l4m::GetInfoRequest& Request::get_info() const {
  // @@protoc_insertion_point(field_get:l4m.Request.get_info)
  return _internal_get_info();
}
inline ::l4m::GetInfoRequest* Request::unsafe_arena_release_get_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Request.get_info)
  if (command_case() == kGetInfo) {
    clear_has_command();
    ::l4m::GetInfoRequest* temp = _impl_.command_.get_info_;
    _impl_.command_.get_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_get_info(::l4m::GetInfoRequest* get_info) {
  clear_command();
  if (get_info) {
    set_has_get_info();
    _impl_.command_.get_info_ = get_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Request.get_info)
}
inline ::l4m::GetInfoRequest* Request::_internal_mutable_get_info() {
  if (command_case() != kGetInfo) {
    clear_command();
    set_has_get_info();
    _impl_.command_.get_info_ = CreateMaybeMessage< ::l4m::GetInfoRequest >(GetArenaForAllocation());
  }
  return _impl_.command_.get_info_;
}
inline ::l4m::GetInfoRequest* Request::mutable_get_info() {
  ::l4m::GetInfoRequest* _msg = _internal_mutable_get_info();
  // @@protoc_insertion_point(field_mutable:l4m.Request.get_info)
  return _msg;
}

inline bool Request::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Request::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline Request::CommandCase Request::command_case() const {
  return Request::CommandCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// uint32 correlation_id = 1;
inline void Response::clear_correlation_id() {
  _impl_.correlation_id_ = 0u;
}
inline ::uint32_t Response::correlation_id() const {
  // @@protoc_insertion_point(field_get:l4m.Response.correlation_id)
  return _internal_correlation_id();
}
inline void Response::set_correlation_id(::uint32_t value) {
  ;
  _internal_set_correlation_id(value);
  // @@protoc_insertion_point(field_set:l4m.Response.correlation_id)
}
inline ::uint32_t Response::_internal_correlation_id() const {
  return _impl_.correlation_id_;
}
inline void Response::_internal_set_correlation_id(::uint32_t value) {
  ;
  _impl_.correlation_id_ = value;
}

// .l4m.BatchSampleTopKResponse sample_top_k = 2;
inline bool Response::has_sample_top_k() const {
  return command_case() == kSampleTopK;
}
inline bool Response::_internal_has_sample_top_k() const {
  return command_case() == kSampleTopK;
}
inline void Response::set_has_sample_top_k() {
  _impl_._oneof_case_[0] = kSampleTopK;
}
inline void Response::clear_sample_top_k() {
  if (command_case() == kSampleTopK) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.sample_top_k_;
    }
    clear_has_command();
  }
}
inline ::l4m::BatchSampleTopKResponse* Response::release_sample_top_k() {
  // @@protoc_insertion_point(field_release:l4m.Response.sample_top_k)
  if (command_case() == kSampleTopK) {
    clear_has_command();
    ::l4m::BatchSampleTopKResponse* temp = _impl_.command_.sample_top_k_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.sample_top_k_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::BatchSampleTopKResponse& Response::_internal_sample_top_k() const {
  return command_case() == kSampleTopK
      ? *_impl_.command_.sample_top_k_
      : reinterpret_cast< ::l4m::BatchSampleTopKResponse&>(::l4m::_BatchSampleTopKResponse_default_instance_);
}
inline const ::l4m::BatchSampleTopKResponse& Response::sample_top_k() const {
  // @@protoc_insertion_point(field_get:l4m.Response.sample_top_k)
  return _internal_sample_top_k();
}
inline ::l4m::BatchSampleTopKResponse* Response::unsafe_arena_release_sample_top_k() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Response.sample_top_k)
  if (command_case() == kSampleTopK) {
    clear_has_command();
    ::l4m::BatchSampleTopKResponse* temp = _impl_.command_.sample_top_k_;
    _impl_.command_.sample_top_k_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_sample_top_k(::l4m::BatchSampleTopKResponse* sample_top_k) {
  clear_command();
  if (sample_top_k) {
    set_has_sample_top_k();
    _impl_.command_.sample_top_k_ = sample_top_k;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Response.sample_top_k)
}
inline ::l4m::BatchSampleTopKResponse* Response::_internal_mutable_sample_top_k() {
  if (command_case() != kSampleTopK) {
    clear_command();
    set_has_sample_top_k();
    _impl_.command_.sample_top_k_ = CreateMaybeMessage< ::l4m::BatchSampleTopKResponse >(GetArenaForAllocation());
  }
  return _impl_.command_.sample_top_k_;
}
inline ::l4m::BatchSampleTopKResponse* Response::mutable_sample_top_k() {
  ::l4m::BatchSampleTopKResponse* _msg = _internal_mutable_sample_top_k();
  // @@protoc_insertion_point(field_mutable:l4m.Response.sample_top_k)
  return _msg;
}

// .l4m.GetInfoResponse get_info = 3;
inline bool Response::has_get_info() const {
  return command_case() == kGetInfo;
}
inline bool Response::_internal_has_get_info() const {
  return command_case() == kGetInfo;
}
inline void Response::set_has_get_info() {
  _impl_._oneof_case_[0] = kGetInfo;
}
inline void Response::clear_get_info() {
  if (command_case() == kGetInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.get_info_;
    }
    clear_has_command();
  }
}
inline ::l4m::GetInfoResponse* Response::release_get_info() {
  // @@protoc_insertion_point(field_release:l4m.Response.get_info)
  if (command_case() == kGetInfo) {
    clear_has_command();
    ::l4m::GetInfoResponse* temp = _impl_.command_.get_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.get_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::l4m::GetInfoResponse& Response::_internal_get_info() const {
  return command_case() == kGetInfo
      ? *_impl_.command_.get_info_
      : reinterpret_cast< ::l4m::GetInfoResponse&>(::l4m::_GetInfoResponse_default_instance_);
}
inline const ::l4m::GetInfoResponse& Response::get_info() const {
  // @@protoc_insertion_point(field_get:l4m.Response.get_info)
  return _internal_get_info();
}
inline ::l4m::GetInfoResponse* Response::unsafe_arena_release_get_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:l4m.Response.get_info)
  if (command_case() == kGetInfo) {
    clear_has_command();
    ::l4m::GetInfoResponse* temp = _impl_.command_.get_info_;
    _impl_.command_.get_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_get_info(::l4m::GetInfoResponse* get_info) {
  clear_command();
  if (get_info) {
    set_has_get_info();
    _impl_.command_.get_info_ = get_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:l4m.Response.get_info)
}
inline ::l4m::GetInfoResponse* Response::_internal_mutable_get_info() {
  if (command_case() != kGetInfo) {
    clear_command();
    set_has_get_info();
    _impl_.command_.get_info_ = CreateMaybeMessage< ::l4m::GetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.command_.get_info_;
}
inline ::l4m::GetInfoResponse* Response::mutable_get_info() {
  ::l4m::GetInfoResponse* _msg = _internal_mutable_get_info();
  // @@protoc_insertion_point(field_mutable:l4m.Response.get_info)
  return _msg;
}

inline bool Response::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Response::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline Response::CommandCase Response::command_case() const {
  return Response::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace l4m


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::l4m::ObjectKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::l4m::ObjectKind>() {
  return ::l4m::ObjectKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_l4m_2eproto_2epb_2eh
