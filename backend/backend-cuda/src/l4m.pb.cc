// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: l4m.proto

#include "l4m.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace l4m {
PROTOBUF_CONSTEXPR Allocate::Allocate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kind_)*/0
  , /* ._impl_.object_id_offset_ = */ 0u

  , /* ._impl_.count_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AllocateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocateDefaultTypeInternal() {}
  union {
    Allocate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocateDefaultTypeInternal _Allocate_default_instance_;
PROTOBUF_CONSTEXPR BatchAllocate::BatchAllocate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchAllocateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchAllocateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchAllocateDefaultTypeInternal() {}
  union {
    BatchAllocate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchAllocateDefaultTypeInternal _BatchAllocate_default_instance_;
PROTOBUF_CONSTEXPR Deallocate::Deallocate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kind_)*/0
  , /* ._impl_.object_id_offset_ = */ 0u

  , /* ._impl_.count_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeallocateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeallocateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeallocateDefaultTypeInternal() {}
  union {
    Deallocate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeallocateDefaultTypeInternal _Deallocate_default_instance_;
PROTOBUF_CONSTEXPR BatchDeallocate::BatchDeallocate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchDeallocateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchDeallocateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchDeallocateDefaultTypeInternal() {}
  union {
    BatchDeallocate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchDeallocateDefaultTypeInternal _BatchDeallocate_default_instance_;
PROTOBUF_CONSTEXPR EmbedText::EmbedText(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.embedding_id_ = */ 0u

  , /* ._impl_.token_id_ = */ 0u

  , /* ._impl_.position_id_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmbedTextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedTextDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedTextDefaultTypeInternal() {}
  union {
    EmbedText _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedTextDefaultTypeInternal _EmbedText_default_instance_;
PROTOBUF_CONSTEXPR BatchEmbedText::BatchEmbedText(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchEmbedTextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchEmbedTextDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchEmbedTextDefaultTypeInternal() {}
  union {
    BatchEmbedText _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchEmbedTextDefaultTypeInternal _BatchEmbedText_default_instance_;
PROTOBUF_CONSTEXPR FillBlock::FillBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.context_block_ids_ = */ {}
  ,/* _impl_._context_block_ids_cached_byte_size_ = */ { 0 }

  , /* ._impl_.input_embedding_ids_ = */ {}
  ,/* _impl_._input_embedding_ids_cached_byte_size_ = */ { 0 }

  , /* ._impl_.output_embedding_ids_ = */ {}
  ,/* _impl_._output_embedding_ids_cached_byte_size_ = */ { 0 }

  , /* ._impl_.last_block_len_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FillBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FillBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FillBlockDefaultTypeInternal() {}
  union {
    FillBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FillBlockDefaultTypeInternal _FillBlock_default_instance_;
PROTOBUF_CONSTEXPR BatchFillBlock::BatchFillBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchFillBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchFillBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchFillBlockDefaultTypeInternal() {}
  union {
    BatchFillBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchFillBlockDefaultTypeInternal _BatchFillBlock_default_instance_;
PROTOBUF_CONSTEXPR MaskBlock::MaskBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.mask_ = */ {}

  , /* ._impl_.block_id_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MaskBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MaskBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MaskBlockDefaultTypeInternal() {}
  union {
    MaskBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MaskBlockDefaultTypeInternal _MaskBlock_default_instance_;
PROTOBUF_CONSTEXPR BatchMaskBlock::BatchMaskBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchMaskBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchMaskBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchMaskBlockDefaultTypeInternal() {}
  union {
    BatchMaskBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchMaskBlockDefaultTypeInternal _BatchMaskBlock_default_instance_;
PROTOBUF_CONSTEXPR CopyBlock::CopyBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.source_block_id_ = */ 0u

  , /* ._impl_.destination_block_id_ = */ 0u

  , /* ._impl_.source_start_ = */ 0u

  , /* ._impl_.destination_start_ = */ 0u

  , /* ._impl_.length_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CopyBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CopyBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CopyBlockDefaultTypeInternal() {}
  union {
    CopyBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CopyBlockDefaultTypeInternal _CopyBlock_default_instance_;
PROTOBUF_CONSTEXPR BatchCopyBlock::BatchCopyBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchCopyBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCopyBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCopyBlockDefaultTypeInternal() {}
  union {
    BatchCopyBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCopyBlockDefaultTypeInternal _BatchCopyBlock_default_instance_;
PROTOBUF_CONSTEXPR DecodeTokenDistribution::DecodeTokenDistribution(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.embedding_id_ = */ 0u

  , /* ._impl_.distribution_id_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DecodeTokenDistributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecodeTokenDistributionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecodeTokenDistributionDefaultTypeInternal() {}
  union {
    DecodeTokenDistribution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecodeTokenDistributionDefaultTypeInternal _DecodeTokenDistribution_default_instance_;
PROTOBUF_CONSTEXPR BatchDecodeTokenDistribution::BatchDecodeTokenDistribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchDecodeTokenDistributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchDecodeTokenDistributionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchDecodeTokenDistributionDefaultTypeInternal() {}
  union {
    BatchDecodeTokenDistribution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchDecodeTokenDistributionDefaultTypeInternal _BatchDecodeTokenDistribution_default_instance_;
PROTOBUF_CONSTEXPR SampleTopKRequest::SampleTopKRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.distribution_id_ = */ 0u

  , /* ._impl_.k_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SampleTopKRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SampleTopKRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SampleTopKRequestDefaultTypeInternal() {}
  union {
    SampleTopKRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SampleTopKRequestDefaultTypeInternal _SampleTopKRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchSampleTopKRequest::BatchSampleTopKRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchSampleTopKRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchSampleTopKRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchSampleTopKRequestDefaultTypeInternal() {}
  union {
    BatchSampleTopKRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchSampleTopKRequestDefaultTypeInternal _BatchSampleTopKRequest_default_instance_;
PROTOBUF_CONSTEXPR SampleTopKResponse::SampleTopKResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.token_ids_ = */ {}
  ,/* _impl_._token_ids_cached_byte_size_ = */ { 0 }

  , /* ._impl_.probabilities_ = */ {}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SampleTopKResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SampleTopKResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SampleTopKResponseDefaultTypeInternal() {}
  union {
    SampleTopKResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SampleTopKResponseDefaultTypeInternal _SampleTopKResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchSampleTopKResponse::BatchSampleTopKResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchSampleTopKResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchSampleTopKResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchSampleTopKResponseDefaultTypeInternal() {}
  union {
    BatchSampleTopKResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchSampleTopKResponseDefaultTypeInternal _BatchSampleTopKResponse_default_instance_;
PROTOBUF_CONSTEXPR GetInfoRequest::GetInfoRequest(
    ::_pbi::ConstantInitialized) {}
struct GetInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetInfoRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetInfoRequestDefaultTypeInternal() {}
  union {
    GetInfoRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetInfoRequestDefaultTypeInternal _GetInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR GetInfoResponse::GetInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /* ._impl_.block_size_ = */ 0u

  , /* ._impl_.num_available_blocks_ = */ 0u

  , /* ._impl_.num_available_embeddings_ = */ 0u

  , /* ._impl_.num_available_distributions_ = */ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetInfoResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetInfoResponseDefaultTypeInternal() {}
  union {
    GetInfoResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetInfoResponseDefaultTypeInternal _GetInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.correlation_id_ = */ 0u

  , /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /* ._impl_.correlation_id_ = */ 0u

  , /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace l4m
static ::_pb::Metadata file_level_metadata_l4m_2eproto[22];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_l4m_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_l4m_2eproto = nullptr;
const ::uint32_t TableStruct_l4m_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::Allocate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::Allocate, _impl_.kind_),
    PROTOBUF_FIELD_OFFSET(::l4m::Allocate, _impl_.object_id_offset_),
    PROTOBUF_FIELD_OFFSET(::l4m::Allocate, _impl_.count_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchAllocate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchAllocate, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::Deallocate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::Deallocate, _impl_.kind_),
    PROTOBUF_FIELD_OFFSET(::l4m::Deallocate, _impl_.object_id_offset_),
    PROTOBUF_FIELD_OFFSET(::l4m::Deallocate, _impl_.count_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchDeallocate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchDeallocate, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::EmbedText, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::EmbedText, _impl_.embedding_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::EmbedText, _impl_.token_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::EmbedText, _impl_.position_id_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchEmbedText, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchEmbedText, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::FillBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::FillBlock, _impl_.last_block_len_),
    PROTOBUF_FIELD_OFFSET(::l4m::FillBlock, _impl_.context_block_ids_),
    PROTOBUF_FIELD_OFFSET(::l4m::FillBlock, _impl_.input_embedding_ids_),
    PROTOBUF_FIELD_OFFSET(::l4m::FillBlock, _impl_.output_embedding_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchFillBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchFillBlock, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::MaskBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::MaskBlock, _impl_.block_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::MaskBlock, _impl_.mask_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchMaskBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchMaskBlock, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _impl_.source_block_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _impl_.destination_block_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _impl_.source_start_),
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _impl_.destination_start_),
    PROTOBUF_FIELD_OFFSET(::l4m::CopyBlock, _impl_.length_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchCopyBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchCopyBlock, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::DecodeTokenDistribution, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::DecodeTokenDistribution, _impl_.embedding_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::DecodeTokenDistribution, _impl_.distribution_id_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchDecodeTokenDistribution, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchDecodeTokenDistribution, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKRequest, _impl_.distribution_id_),
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKRequest, _impl_.k_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchSampleTopKRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchSampleTopKRequest, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKResponse, _impl_.token_ids_),
    PROTOBUF_FIELD_OFFSET(::l4m::SampleTopKResponse, _impl_.probabilities_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::BatchSampleTopKResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::BatchSampleTopKResponse, _impl_.items_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.version_),
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.model_name_),
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.block_size_),
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.num_available_blocks_),
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.num_available_embeddings_),
    PROTOBUF_FIELD_OFFSET(::l4m::GetInfoResponse, _impl_.num_available_distributions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::Request, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::l4m::Request, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::Request, _impl_.correlation_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::l4m::Request, _impl_.command_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::l4m::Response, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::l4m::Response, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::l4m::Response, _impl_.correlation_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::l4m::Response, _impl_.command_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::l4m::Allocate)},
        { 11, -1, -1, sizeof(::l4m::BatchAllocate)},
        { 20, -1, -1, sizeof(::l4m::Deallocate)},
        { 31, -1, -1, sizeof(::l4m::BatchDeallocate)},
        { 40, -1, -1, sizeof(::l4m::EmbedText)},
        { 51, -1, -1, sizeof(::l4m::BatchEmbedText)},
        { 60, -1, -1, sizeof(::l4m::FillBlock)},
        { 72, -1, -1, sizeof(::l4m::BatchFillBlock)},
        { 81, -1, -1, sizeof(::l4m::MaskBlock)},
        { 91, -1, -1, sizeof(::l4m::BatchMaskBlock)},
        { 100, -1, -1, sizeof(::l4m::CopyBlock)},
        { 113, -1, -1, sizeof(::l4m::BatchCopyBlock)},
        { 122, -1, -1, sizeof(::l4m::DecodeTokenDistribution)},
        { 132, -1, -1, sizeof(::l4m::BatchDecodeTokenDistribution)},
        { 141, -1, -1, sizeof(::l4m::SampleTopKRequest)},
        { 151, -1, -1, sizeof(::l4m::BatchSampleTopKRequest)},
        { 160, -1, -1, sizeof(::l4m::SampleTopKResponse)},
        { 170, -1, -1, sizeof(::l4m::BatchSampleTopKResponse)},
        { 179, -1, -1, sizeof(::l4m::GetInfoRequest)},
        { 187, -1, -1, sizeof(::l4m::GetInfoResponse)},
        { 201, -1, -1, sizeof(::l4m::Request)},
        { 220, -1, -1, sizeof(::l4m::Response)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::l4m::_Allocate_default_instance_._instance,
    &::l4m::_BatchAllocate_default_instance_._instance,
    &::l4m::_Deallocate_default_instance_._instance,
    &::l4m::_BatchDeallocate_default_instance_._instance,
    &::l4m::_EmbedText_default_instance_._instance,
    &::l4m::_BatchEmbedText_default_instance_._instance,
    &::l4m::_FillBlock_default_instance_._instance,
    &::l4m::_BatchFillBlock_default_instance_._instance,
    &::l4m::_MaskBlock_default_instance_._instance,
    &::l4m::_BatchMaskBlock_default_instance_._instance,
    &::l4m::_CopyBlock_default_instance_._instance,
    &::l4m::_BatchCopyBlock_default_instance_._instance,
    &::l4m::_DecodeTokenDistribution_default_instance_._instance,
    &::l4m::_BatchDecodeTokenDistribution_default_instance_._instance,
    &::l4m::_SampleTopKRequest_default_instance_._instance,
    &::l4m::_BatchSampleTopKRequest_default_instance_._instance,
    &::l4m::_SampleTopKResponse_default_instance_._instance,
    &::l4m::_BatchSampleTopKResponse_default_instance_._instance,
    &::l4m::_GetInfoRequest_default_instance_._instance,
    &::l4m::_GetInfoResponse_default_instance_._instance,
    &::l4m::_Request_default_instance_._instance,
    &::l4m::_Response_default_instance_._instance,
};
const char descriptor_table_protodef_l4m_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\tl4m.proto\022\003l4m\"R\n\010Allocate\022\035\n\004kind\030\001 \001"
    "(\0162\017.l4m.ObjectKind\022\030\n\020object_id_offset\030"
    "\002 \001(\r\022\r\n\005count\030\003 \001(\r\"-\n\rBatchAllocate\022\034\n"
    "\005items\030\001 \003(\0132\r.l4m.Allocate\"T\n\nDeallocat"
    "e\022\035\n\004kind\030\001 \001(\0162\017.l4m.ObjectKind\022\030\n\020obje"
    "ct_id_offset\030\002 \001(\r\022\r\n\005count\030\003 \001(\r\"1\n\017Bat"
    "chDeallocate\022\036\n\005items\030\001 \003(\0132\017.l4m.Deallo"
    "cate\"H\n\tEmbedText\022\024\n\014embedding_id\030\001 \001(\r\022"
    "\020\n\010token_id\030\002 \001(\r\022\023\n\013position_id\030\003 \001(\r\"/"
    "\n\016BatchEmbedText\022\035\n\005items\030\001 \003(\0132\016.l4m.Em"
    "bedText\"y\n\tFillBlock\022\026\n\016last_block_len\030\001"
    " \001(\r\022\031\n\021context_block_ids\030\002 \003(\r\022\033\n\023input"
    "_embedding_ids\030\003 \003(\r\022\034\n\024output_embedding"
    "_ids\030\004 \003(\r\"/\n\016BatchFillBlock\022\035\n\005items\030\001 "
    "\003(\0132\016.l4m.FillBlock\"+\n\tMaskBlock\022\020\n\010bloc"
    "k_id\030\001 \001(\r\022\014\n\004mask\030\002 \003(\010\"/\n\016BatchMaskBlo"
    "ck\022\035\n\005items\030\001 \003(\0132\016.l4m.MaskBlock\"\203\001\n\tCo"
    "pyBlock\022\027\n\017source_block_id\030\001 \001(\r\022\034\n\024dest"
    "ination_block_id\030\002 \001(\r\022\024\n\014source_start\030\003"
    " \001(\r\022\031\n\021destination_start\030\004 \001(\r\022\016\n\006lengt"
    "h\030\005 \001(\r\"/\n\016BatchCopyBlock\022\035\n\005items\030\001 \003(\013"
    "2\016.l4m.CopyBlock\"H\n\027DecodeTokenDistribut"
    "ion\022\024\n\014embedding_id\030\001 \001(\r\022\027\n\017distributio"
    "n_id\030\002 \001(\r\"K\n\034BatchDecodeTokenDistributi"
    "on\022+\n\005items\030\001 \003(\0132\034.l4m.DecodeTokenDistr"
    "ibution\"7\n\021SampleTopKRequest\022\027\n\017distribu"
    "tion_id\030\001 \001(\r\022\t\n\001k\030\002 \001(\r\"\?\n\026BatchSampleT"
    "opKRequest\022%\n\005items\030\001 \003(\0132\026.l4m.SampleTo"
    "pKRequest\">\n\022SampleTopKResponse\022\021\n\ttoken"
    "_ids\030\001 \003(\r\022\025\n\rprobabilities\030\002 \003(\002\"A\n\027Bat"
    "chSampleTopKResponse\022&\n\005items\030\001 \003(\0132\027.l4"
    "m.SampleTopKResponse\"\020\n\016GetInfoRequest\"\257"
    "\001\n\017GetInfoResponse\022\017\n\007version\030\001 \001(\t\022\022\n\nm"
    "odel_name\030\002 \001(\t\022\022\n\nblock_size\030\003 \001(\r\022\034\n\024n"
    "um_available_blocks\030\004 \001(\r\022 \n\030num_availab"
    "le_embeddings\030\005 \001(\r\022#\n\033num_available_dis"
    "tributions\030\006 \001(\r\"\332\003\n\007Request\022\026\n\016correlat"
    "ion_id\030\001 \001(\r\022&\n\010allocate\030\002 \001(\0132\022.l4m.Bat"
    "chAllocateH\000\022*\n\ndeallocate\030\003 \001(\0132\024.l4m.B"
    "atchDeallocateH\000\022)\n\nembed_text\030\004 \001(\0132\023.l"
    "4m.BatchEmbedTextH\000\022)\n\nfill_block\030\005 \001(\0132"
    "\023.l4m.BatchFillBlockH\000\022)\n\nmask_block\030\006 \001"
    "(\0132\023.l4m.BatchMaskBlockH\000\022)\n\ncopy_block\030"
    "\007 \001(\0132\023.l4m.BatchCopyBlockH\000\022F\n\031decode_t"
    "oken_distribution\030\010 \001(\0132!.l4m.BatchDecod"
    "eTokenDistributionH\000\022;\n\024sample_top_k_req"
    "uest\030\t \001(\0132\033.l4m.BatchSampleTopKRequestH"
    "\000\022\'\n\010get_info\030\n \001(\0132\023.l4m.GetInfoRequest"
    "H\000B\t\n\007command\"\215\001\n\010Response\022\026\n\016correlatio"
    "n_id\030\001 \001(\r\0224\n\014sample_top_k\030\002 \001(\0132\034.l4m.B"
    "atchSampleTopKResponseH\000\022(\n\010get_info\030\003 \001"
    "(\0132\024.l4m.GetInfoResponseH\000B\t\n\007command*n\n"
    "\nObjectKind\022\033\n\027OBJECT_KIND_UNSPECIFIED\020\000"
    "\022\030\n\024OBJECT_KIND_KV_BLOCK\020\001\022\023\n\017OBJECT_KIN"
    "D_EMB\020\002\022\024\n\020OBJECT_KIND_DIST\020\003b\006proto3"
};
static ::absl::once_flag descriptor_table_l4m_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_l4m_2eproto = {
    false,
    false,
    2197,
    descriptor_table_protodef_l4m_2eproto,
    "l4m.proto",
    &descriptor_table_l4m_2eproto_once,
    nullptr,
    0,
    22,
    schemas,
    file_default_instances,
    TableStruct_l4m_2eproto::offsets,
    file_level_metadata_l4m_2eproto,
    file_level_enum_descriptors_l4m_2eproto,
    file_level_service_descriptors_l4m_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_l4m_2eproto_getter() {
  return &descriptor_table_l4m_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_l4m_2eproto(&descriptor_table_l4m_2eproto);
namespace l4m {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_l4m_2eproto);
  return file_level_enum_descriptors_l4m_2eproto[0];
}
bool ObjectKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Allocate::_Internal {
 public:
};

Allocate::Allocate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.Allocate)
}
Allocate::Allocate(const Allocate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.Allocate)
}

inline void Allocate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.kind_){0}
    , decltype(_impl_.object_id_offset_) { 0u }

    , decltype(_impl_.count_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Allocate::~Allocate() {
  // @@protoc_insertion_point(destructor:l4m.Allocate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Allocate::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Allocate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Allocate::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.Allocate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.kind_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Allocate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .l4m.ObjectKind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::l4m::ObjectKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 object_id_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.object_id_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Allocate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.Allocate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .l4m.ObjectKind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // uint32 object_id_offset = 2;
  if (this->_internal_object_id_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_object_id_offset(), target);
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.Allocate)
  return target;
}

::size_t Allocate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.Allocate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .l4m.ObjectKind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // uint32 object_id_offset = 2;
  if (this->_internal_object_id_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_object_id_offset());
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Allocate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Allocate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Allocate::GetClassData() const { return &_class_data_; }


void Allocate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Allocate*>(&to_msg);
  auto& from = static_cast<const Allocate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.Allocate)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (from._internal_object_id_offset() != 0) {
    _this->_internal_set_object_id_offset(from._internal_object_id_offset());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Allocate::CopyFrom(const Allocate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.Allocate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Allocate::IsInitialized() const {
  return true;
}

void Allocate::InternalSwap(Allocate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Allocate, _impl_.count_)
      + sizeof(Allocate::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(Allocate, _impl_.kind_)>(
          reinterpret_cast<char*>(&_impl_.kind_),
          reinterpret_cast<char*>(&other->_impl_.kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Allocate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[0]);
}
// ===================================================================

class BatchAllocate::_Internal {
 public:
};

BatchAllocate::BatchAllocate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchAllocate)
}
BatchAllocate::BatchAllocate(const BatchAllocate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchAllocate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchAllocate)
}

inline void BatchAllocate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchAllocate::~BatchAllocate() {
  // @@protoc_insertion_point(destructor:l4m.BatchAllocate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchAllocate::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchAllocate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchAllocate::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchAllocate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchAllocate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.Allocate items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchAllocate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchAllocate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.Allocate items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchAllocate)
  return target;
}

::size_t BatchAllocate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchAllocate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.Allocate items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchAllocate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchAllocate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchAllocate::GetClassData() const { return &_class_data_; }


void BatchAllocate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchAllocate*>(&to_msg);
  auto& from = static_cast<const BatchAllocate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchAllocate)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchAllocate::CopyFrom(const BatchAllocate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchAllocate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchAllocate::IsInitialized() const {
  return true;
}

void BatchAllocate::InternalSwap(BatchAllocate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchAllocate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[1]);
}
// ===================================================================

class Deallocate::_Internal {
 public:
};

Deallocate::Deallocate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.Deallocate)
}
Deallocate::Deallocate(const Deallocate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.Deallocate)
}

inline void Deallocate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.kind_){0}
    , decltype(_impl_.object_id_offset_) { 0u }

    , decltype(_impl_.count_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Deallocate::~Deallocate() {
  // @@protoc_insertion_point(destructor:l4m.Deallocate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Deallocate::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Deallocate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Deallocate::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.Deallocate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.kind_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Deallocate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .l4m.ObjectKind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::l4m::ObjectKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 object_id_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.object_id_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Deallocate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.Deallocate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .l4m.ObjectKind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // uint32 object_id_offset = 2;
  if (this->_internal_object_id_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_object_id_offset(), target);
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.Deallocate)
  return target;
}

::size_t Deallocate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.Deallocate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .l4m.ObjectKind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // uint32 object_id_offset = 2;
  if (this->_internal_object_id_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_object_id_offset());
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Deallocate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Deallocate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Deallocate::GetClassData() const { return &_class_data_; }


void Deallocate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Deallocate*>(&to_msg);
  auto& from = static_cast<const Deallocate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.Deallocate)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (from._internal_object_id_offset() != 0) {
    _this->_internal_set_object_id_offset(from._internal_object_id_offset());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Deallocate::CopyFrom(const Deallocate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.Deallocate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Deallocate::IsInitialized() const {
  return true;
}

void Deallocate::InternalSwap(Deallocate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Deallocate, _impl_.count_)
      + sizeof(Deallocate::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(Deallocate, _impl_.kind_)>(
          reinterpret_cast<char*>(&_impl_.kind_),
          reinterpret_cast<char*>(&other->_impl_.kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Deallocate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[2]);
}
// ===================================================================

class BatchDeallocate::_Internal {
 public:
};

BatchDeallocate::BatchDeallocate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchDeallocate)
}
BatchDeallocate::BatchDeallocate(const BatchDeallocate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchDeallocate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchDeallocate)
}

inline void BatchDeallocate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchDeallocate::~BatchDeallocate() {
  // @@protoc_insertion_point(destructor:l4m.BatchDeallocate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchDeallocate::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchDeallocate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchDeallocate::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchDeallocate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchDeallocate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.Deallocate items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchDeallocate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchDeallocate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.Deallocate items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchDeallocate)
  return target;
}

::size_t BatchDeallocate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchDeallocate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.Deallocate items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchDeallocate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchDeallocate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchDeallocate::GetClassData() const { return &_class_data_; }


void BatchDeallocate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchDeallocate*>(&to_msg);
  auto& from = static_cast<const BatchDeallocate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchDeallocate)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchDeallocate::CopyFrom(const BatchDeallocate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchDeallocate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchDeallocate::IsInitialized() const {
  return true;
}

void BatchDeallocate::InternalSwap(BatchDeallocate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchDeallocate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[3]);
}
// ===================================================================

class EmbedText::_Internal {
 public:
};

EmbedText::EmbedText(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.EmbedText)
}
EmbedText::EmbedText(const EmbedText& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.EmbedText)
}

inline void EmbedText::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.embedding_id_) { 0u }

    , decltype(_impl_.token_id_) { 0u }

    , decltype(_impl_.position_id_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EmbedText::~EmbedText() {
  // @@protoc_insertion_point(destructor:l4m.EmbedText)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedText::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void EmbedText::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedText::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.EmbedText)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.embedding_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.position_id_) -
      reinterpret_cast<char*>(&_impl_.embedding_id_)) + sizeof(_impl_.position_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedText::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 embedding_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.embedding_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 token_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 position_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.position_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EmbedText::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.EmbedText)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 embedding_id = 1;
  if (this->_internal_embedding_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_embedding_id(), target);
  }

  // uint32 token_id = 2;
  if (this->_internal_token_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_token_id(), target);
  }

  // uint32 position_id = 3;
  if (this->_internal_position_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_position_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.EmbedText)
  return target;
}

::size_t EmbedText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.EmbedText)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 embedding_id = 1;
  if (this->_internal_embedding_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_embedding_id());
  }

  // uint32 token_id = 2;
  if (this->_internal_token_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_token_id());
  }

  // uint32 position_id = 3;
  if (this->_internal_position_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_position_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedText::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedText::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedText::GetClassData() const { return &_class_data_; }


void EmbedText::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedText*>(&to_msg);
  auto& from = static_cast<const EmbedText&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.EmbedText)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_embedding_id() != 0) {
    _this->_internal_set_embedding_id(from._internal_embedding_id());
  }
  if (from._internal_token_id() != 0) {
    _this->_internal_set_token_id(from._internal_token_id());
  }
  if (from._internal_position_id() != 0) {
    _this->_internal_set_position_id(from._internal_position_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedText::CopyFrom(const EmbedText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.EmbedText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedText::IsInitialized() const {
  return true;
}

void EmbedText::InternalSwap(EmbedText* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmbedText, _impl_.position_id_)
      + sizeof(EmbedText::_impl_.position_id_)
      - PROTOBUF_FIELD_OFFSET(EmbedText, _impl_.embedding_id_)>(
          reinterpret_cast<char*>(&_impl_.embedding_id_),
          reinterpret_cast<char*>(&other->_impl_.embedding_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedText::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[4]);
}
// ===================================================================

class BatchEmbedText::_Internal {
 public:
};

BatchEmbedText::BatchEmbedText(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchEmbedText)
}
BatchEmbedText::BatchEmbedText(const BatchEmbedText& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchEmbedText* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchEmbedText)
}

inline void BatchEmbedText::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchEmbedText::~BatchEmbedText() {
  // @@protoc_insertion_point(destructor:l4m.BatchEmbedText)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchEmbedText::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchEmbedText::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchEmbedText::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchEmbedText)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchEmbedText::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.EmbedText items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchEmbedText::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchEmbedText)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.EmbedText items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchEmbedText)
  return target;
}

::size_t BatchEmbedText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchEmbedText)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.EmbedText items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchEmbedText::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchEmbedText::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchEmbedText::GetClassData() const { return &_class_data_; }


void BatchEmbedText::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchEmbedText*>(&to_msg);
  auto& from = static_cast<const BatchEmbedText&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchEmbedText)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchEmbedText::CopyFrom(const BatchEmbedText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchEmbedText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchEmbedText::IsInitialized() const {
  return true;
}

void BatchEmbedText::InternalSwap(BatchEmbedText* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchEmbedText::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[5]);
}
// ===================================================================

class FillBlock::_Internal {
 public:
};

FillBlock::FillBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.FillBlock)
}
FillBlock::FillBlock(const FillBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FillBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.context_block_ids_) { from._impl_.context_block_ids_ }
    ,/* _impl_._context_block_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.input_embedding_ids_) { from._impl_.input_embedding_ids_ }
    ,/* _impl_._input_embedding_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.output_embedding_ids_) { from._impl_.output_embedding_ids_ }
    ,/* _impl_._output_embedding_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.last_block_len_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.last_block_len_ = from._impl_.last_block_len_;
  // @@protoc_insertion_point(copy_constructor:l4m.FillBlock)
}

inline void FillBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.context_block_ids_) { arena }
    ,/* _impl_._context_block_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.input_embedding_ids_) { arena }
    ,/* _impl_._input_embedding_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.output_embedding_ids_) { arena }
    ,/* _impl_._output_embedding_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.last_block_len_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FillBlock::~FillBlock() {
  // @@protoc_insertion_point(destructor:l4m.FillBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FillBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.context_block_ids_.~RepeatedField();
  _impl_.input_embedding_ids_.~RepeatedField();
  _impl_.output_embedding_ids_.~RepeatedField();
}

void FillBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FillBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.FillBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.context_block_ids_.Clear();
  _impl_.input_embedding_ids_.Clear();
  _impl_.output_embedding_ids_.Clear();
  _impl_.last_block_len_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FillBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 last_block_len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.last_block_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated uint32 context_block_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_context_block_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 16) {
          _internal_add_context_block_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated uint32 input_embedding_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_input_embedding_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 24) {
          _internal_add_input_embedding_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated uint32 output_embedding_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_output_embedding_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 32) {
          _internal_add_output_embedding_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FillBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.FillBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 last_block_len = 1;
  if (this->_internal_last_block_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_last_block_len(), target);
  }

  // repeated uint32 context_block_ids = 2;
  {
    int byte_size = _impl_._context_block_ids_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(2, _internal_context_block_ids(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 input_embedding_ids = 3;
  {
    int byte_size = _impl_._input_embedding_ids_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(3, _internal_input_embedding_ids(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 output_embedding_ids = 4;
  {
    int byte_size = _impl_._output_embedding_ids_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(4, _internal_output_embedding_ids(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.FillBlock)
  return target;
}

::size_t FillBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.FillBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 context_block_ids = 2;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.context_block_ids_)
    ;
    _impl_._context_block_ids_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated uint32 input_embedding_ids = 3;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.input_embedding_ids_)
    ;
    _impl_._input_embedding_ids_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated uint32 output_embedding_ids = 4;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.output_embedding_ids_)
    ;
    _impl_._output_embedding_ids_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // uint32 last_block_len = 1;
  if (this->_internal_last_block_len() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_last_block_len());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FillBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FillBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FillBlock::GetClassData() const { return &_class_data_; }


void FillBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FillBlock*>(&to_msg);
  auto& from = static_cast<const FillBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.FillBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.context_block_ids_.MergeFrom(from._impl_.context_block_ids_);
  _this->_impl_.input_embedding_ids_.MergeFrom(from._impl_.input_embedding_ids_);
  _this->_impl_.output_embedding_ids_.MergeFrom(from._impl_.output_embedding_ids_);
  if (from._internal_last_block_len() != 0) {
    _this->_internal_set_last_block_len(from._internal_last_block_len());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FillBlock::CopyFrom(const FillBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.FillBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillBlock::IsInitialized() const {
  return true;
}

void FillBlock::InternalSwap(FillBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.context_block_ids_.InternalSwap(&other->_impl_.context_block_ids_);
  _impl_.input_embedding_ids_.InternalSwap(&other->_impl_.input_embedding_ids_);
  _impl_.output_embedding_ids_.InternalSwap(&other->_impl_.output_embedding_ids_);

  swap(_impl_.last_block_len_, other->_impl_.last_block_len_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FillBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[6]);
}
// ===================================================================

class BatchFillBlock::_Internal {
 public:
};

BatchFillBlock::BatchFillBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchFillBlock)
}
BatchFillBlock::BatchFillBlock(const BatchFillBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchFillBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchFillBlock)
}

inline void BatchFillBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchFillBlock::~BatchFillBlock() {
  // @@protoc_insertion_point(destructor:l4m.BatchFillBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchFillBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchFillBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchFillBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchFillBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchFillBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.FillBlock items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchFillBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchFillBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.FillBlock items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchFillBlock)
  return target;
}

::size_t BatchFillBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchFillBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.FillBlock items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchFillBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchFillBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchFillBlock::GetClassData() const { return &_class_data_; }


void BatchFillBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchFillBlock*>(&to_msg);
  auto& from = static_cast<const BatchFillBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchFillBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchFillBlock::CopyFrom(const BatchFillBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchFillBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchFillBlock::IsInitialized() const {
  return true;
}

void BatchFillBlock::InternalSwap(BatchFillBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchFillBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[7]);
}
// ===================================================================

class MaskBlock::_Internal {
 public:
};

MaskBlock::MaskBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.MaskBlock)
}
MaskBlock::MaskBlock(const MaskBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MaskBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mask_) { from._impl_.mask_ }

    , decltype(_impl_.block_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.block_id_ = from._impl_.block_id_;
  // @@protoc_insertion_point(copy_constructor:l4m.MaskBlock)
}

inline void MaskBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mask_) { arena }

    , decltype(_impl_.block_id_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MaskBlock::~MaskBlock() {
  // @@protoc_insertion_point(destructor:l4m.MaskBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MaskBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mask_.~RepeatedField();
}

void MaskBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MaskBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.MaskBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mask_.Clear();
  _impl_.block_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MaskBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 block_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.block_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bool mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_mask(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 16) {
          _internal_add_mask(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MaskBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.MaskBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 block_id = 1;
  if (this->_internal_block_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_block_id(), target);
  }

  // repeated bool mask = 2;
  if (this->_internal_mask_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.MaskBlock)
  return target;
}

::size_t MaskBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.MaskBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool mask = 2;
  {
    std::size_t data_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_mask_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // uint32 block_id = 1;
  if (this->_internal_block_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_block_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MaskBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MaskBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MaskBlock::GetClassData() const { return &_class_data_; }


void MaskBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MaskBlock*>(&to_msg);
  auto& from = static_cast<const MaskBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.MaskBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mask_.MergeFrom(from._impl_.mask_);
  if (from._internal_block_id() != 0) {
    _this->_internal_set_block_id(from._internal_block_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MaskBlock::CopyFrom(const MaskBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.MaskBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaskBlock::IsInitialized() const {
  return true;
}

void MaskBlock::InternalSwap(MaskBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.mask_.InternalSwap(&other->_impl_.mask_);

  swap(_impl_.block_id_, other->_impl_.block_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MaskBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[8]);
}
// ===================================================================

class BatchMaskBlock::_Internal {
 public:
};

BatchMaskBlock::BatchMaskBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchMaskBlock)
}
BatchMaskBlock::BatchMaskBlock(const BatchMaskBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchMaskBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchMaskBlock)
}

inline void BatchMaskBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchMaskBlock::~BatchMaskBlock() {
  // @@protoc_insertion_point(destructor:l4m.BatchMaskBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchMaskBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchMaskBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchMaskBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchMaskBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchMaskBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.MaskBlock items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchMaskBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchMaskBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.MaskBlock items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchMaskBlock)
  return target;
}

::size_t BatchMaskBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchMaskBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.MaskBlock items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchMaskBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchMaskBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchMaskBlock::GetClassData() const { return &_class_data_; }


void BatchMaskBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchMaskBlock*>(&to_msg);
  auto& from = static_cast<const BatchMaskBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchMaskBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchMaskBlock::CopyFrom(const BatchMaskBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchMaskBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchMaskBlock::IsInitialized() const {
  return true;
}

void BatchMaskBlock::InternalSwap(BatchMaskBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchMaskBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[9]);
}
// ===================================================================

class CopyBlock::_Internal {
 public:
};

CopyBlock::CopyBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.CopyBlock)
}
CopyBlock::CopyBlock(const CopyBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.CopyBlock)
}

inline void CopyBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.source_block_id_) { 0u }

    , decltype(_impl_.destination_block_id_) { 0u }

    , decltype(_impl_.source_start_) { 0u }

    , decltype(_impl_.destination_start_) { 0u }

    , decltype(_impl_.length_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CopyBlock::~CopyBlock() {
  // @@protoc_insertion_point(destructor:l4m.CopyBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CopyBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CopyBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CopyBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.CopyBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.source_block_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.length_) -
      reinterpret_cast<char*>(&_impl_.source_block_id_)) + sizeof(_impl_.length_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CopyBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 source_block_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.source_block_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 destination_block_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.destination_block_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 source_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.source_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 destination_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.destination_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CopyBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.CopyBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 source_block_id = 1;
  if (this->_internal_source_block_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_source_block_id(), target);
  }

  // uint32 destination_block_id = 2;
  if (this->_internal_destination_block_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_destination_block_id(), target);
  }

  // uint32 source_start = 3;
  if (this->_internal_source_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_source_start(), target);
  }

  // uint32 destination_start = 4;
  if (this->_internal_destination_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_destination_start(), target);
  }

  // uint32 length = 5;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.CopyBlock)
  return target;
}

::size_t CopyBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.CopyBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 source_block_id = 1;
  if (this->_internal_source_block_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_source_block_id());
  }

  // uint32 destination_block_id = 2;
  if (this->_internal_destination_block_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_destination_block_id());
  }

  // uint32 source_start = 3;
  if (this->_internal_source_start() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_source_start());
  }

  // uint32 destination_start = 4;
  if (this->_internal_destination_start() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_destination_start());
  }

  // uint32 length = 5;
  if (this->_internal_length() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CopyBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CopyBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CopyBlock::GetClassData() const { return &_class_data_; }


void CopyBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CopyBlock*>(&to_msg);
  auto& from = static_cast<const CopyBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.CopyBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_block_id() != 0) {
    _this->_internal_set_source_block_id(from._internal_source_block_id());
  }
  if (from._internal_destination_block_id() != 0) {
    _this->_internal_set_destination_block_id(from._internal_destination_block_id());
  }
  if (from._internal_source_start() != 0) {
    _this->_internal_set_source_start(from._internal_source_start());
  }
  if (from._internal_destination_start() != 0) {
    _this->_internal_set_destination_start(from._internal_destination_start());
  }
  if (from._internal_length() != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CopyBlock::CopyFrom(const CopyBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.CopyBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CopyBlock::IsInitialized() const {
  return true;
}

void CopyBlock::InternalSwap(CopyBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CopyBlock, _impl_.length_)
      + sizeof(CopyBlock::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(CopyBlock, _impl_.source_block_id_)>(
          reinterpret_cast<char*>(&_impl_.source_block_id_),
          reinterpret_cast<char*>(&other->_impl_.source_block_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CopyBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[10]);
}
// ===================================================================

class BatchCopyBlock::_Internal {
 public:
};

BatchCopyBlock::BatchCopyBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchCopyBlock)
}
BatchCopyBlock::BatchCopyBlock(const BatchCopyBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchCopyBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchCopyBlock)
}

inline void BatchCopyBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchCopyBlock::~BatchCopyBlock() {
  // @@protoc_insertion_point(destructor:l4m.BatchCopyBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchCopyBlock::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchCopyBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchCopyBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchCopyBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchCopyBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.CopyBlock items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchCopyBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchCopyBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.CopyBlock items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchCopyBlock)
  return target;
}

::size_t BatchCopyBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchCopyBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.CopyBlock items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchCopyBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchCopyBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchCopyBlock::GetClassData() const { return &_class_data_; }


void BatchCopyBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchCopyBlock*>(&to_msg);
  auto& from = static_cast<const BatchCopyBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchCopyBlock)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchCopyBlock::CopyFrom(const BatchCopyBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchCopyBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchCopyBlock::IsInitialized() const {
  return true;
}

void BatchCopyBlock::InternalSwap(BatchCopyBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchCopyBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[11]);
}
// ===================================================================

class DecodeTokenDistribution::_Internal {
 public:
};

DecodeTokenDistribution::DecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.DecodeTokenDistribution)
}
DecodeTokenDistribution::DecodeTokenDistribution(const DecodeTokenDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.DecodeTokenDistribution)
}

inline void DecodeTokenDistribution::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.embedding_id_) { 0u }

    , decltype(_impl_.distribution_id_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DecodeTokenDistribution::~DecodeTokenDistribution() {
  // @@protoc_insertion_point(destructor:l4m.DecodeTokenDistribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecodeTokenDistribution::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DecodeTokenDistribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DecodeTokenDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.DecodeTokenDistribution)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.embedding_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.distribution_id_) -
      reinterpret_cast<char*>(&_impl_.embedding_id_)) + sizeof(_impl_.distribution_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecodeTokenDistribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 embedding_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.embedding_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 distribution_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.distribution_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DecodeTokenDistribution::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.DecodeTokenDistribution)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 embedding_id = 1;
  if (this->_internal_embedding_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_embedding_id(), target);
  }

  // uint32 distribution_id = 2;
  if (this->_internal_distribution_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_distribution_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.DecodeTokenDistribution)
  return target;
}

::size_t DecodeTokenDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.DecodeTokenDistribution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 embedding_id = 1;
  if (this->_internal_embedding_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_embedding_id());
  }

  // uint32 distribution_id = 2;
  if (this->_internal_distribution_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_distribution_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecodeTokenDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DecodeTokenDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecodeTokenDistribution::GetClassData() const { return &_class_data_; }


void DecodeTokenDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DecodeTokenDistribution*>(&to_msg);
  auto& from = static_cast<const DecodeTokenDistribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.DecodeTokenDistribution)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_embedding_id() != 0) {
    _this->_internal_set_embedding_id(from._internal_embedding_id());
  }
  if (from._internal_distribution_id() != 0) {
    _this->_internal_set_distribution_id(from._internal_distribution_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecodeTokenDistribution::CopyFrom(const DecodeTokenDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.DecodeTokenDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecodeTokenDistribution::IsInitialized() const {
  return true;
}

void DecodeTokenDistribution::InternalSwap(DecodeTokenDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecodeTokenDistribution, _impl_.distribution_id_)
      + sizeof(DecodeTokenDistribution::_impl_.distribution_id_)
      - PROTOBUF_FIELD_OFFSET(DecodeTokenDistribution, _impl_.embedding_id_)>(
          reinterpret_cast<char*>(&_impl_.embedding_id_),
          reinterpret_cast<char*>(&other->_impl_.embedding_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecodeTokenDistribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[12]);
}
// ===================================================================

class BatchDecodeTokenDistribution::_Internal {
 public:
};

BatchDecodeTokenDistribution::BatchDecodeTokenDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchDecodeTokenDistribution)
}
BatchDecodeTokenDistribution::BatchDecodeTokenDistribution(const BatchDecodeTokenDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchDecodeTokenDistribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchDecodeTokenDistribution)
}

inline void BatchDecodeTokenDistribution::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchDecodeTokenDistribution::~BatchDecodeTokenDistribution() {
  // @@protoc_insertion_point(destructor:l4m.BatchDecodeTokenDistribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchDecodeTokenDistribution::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchDecodeTokenDistribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchDecodeTokenDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchDecodeTokenDistribution)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchDecodeTokenDistribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.DecodeTokenDistribution items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchDecodeTokenDistribution::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchDecodeTokenDistribution)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.DecodeTokenDistribution items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchDecodeTokenDistribution)
  return target;
}

::size_t BatchDecodeTokenDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchDecodeTokenDistribution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.DecodeTokenDistribution items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchDecodeTokenDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchDecodeTokenDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchDecodeTokenDistribution::GetClassData() const { return &_class_data_; }


void BatchDecodeTokenDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchDecodeTokenDistribution*>(&to_msg);
  auto& from = static_cast<const BatchDecodeTokenDistribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchDecodeTokenDistribution)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchDecodeTokenDistribution::CopyFrom(const BatchDecodeTokenDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchDecodeTokenDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchDecodeTokenDistribution::IsInitialized() const {
  return true;
}

void BatchDecodeTokenDistribution::InternalSwap(BatchDecodeTokenDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchDecodeTokenDistribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[13]);
}
// ===================================================================

class SampleTopKRequest::_Internal {
 public:
};

SampleTopKRequest::SampleTopKRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.SampleTopKRequest)
}
SampleTopKRequest::SampleTopKRequest(const SampleTopKRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.SampleTopKRequest)
}

inline void SampleTopKRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.distribution_id_) { 0u }

    , decltype(_impl_.k_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SampleTopKRequest::~SampleTopKRequest() {
  // @@protoc_insertion_point(destructor:l4m.SampleTopKRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SampleTopKRequest::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SampleTopKRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SampleTopKRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.SampleTopKRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.distribution_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.k_) -
      reinterpret_cast<char*>(&_impl_.distribution_id_)) + sizeof(_impl_.k_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SampleTopKRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 distribution_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.distribution_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 k = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.k_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SampleTopKRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.SampleTopKRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 distribution_id = 1;
  if (this->_internal_distribution_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_distribution_id(), target);
  }

  // uint32 k = 2;
  if (this->_internal_k() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_k(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.SampleTopKRequest)
  return target;
}

::size_t SampleTopKRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.SampleTopKRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 distribution_id = 1;
  if (this->_internal_distribution_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_distribution_id());
  }

  // uint32 k = 2;
  if (this->_internal_k() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_k());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SampleTopKRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SampleTopKRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SampleTopKRequest::GetClassData() const { return &_class_data_; }


void SampleTopKRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SampleTopKRequest*>(&to_msg);
  auto& from = static_cast<const SampleTopKRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.SampleTopKRequest)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_distribution_id() != 0) {
    _this->_internal_set_distribution_id(from._internal_distribution_id());
  }
  if (from._internal_k() != 0) {
    _this->_internal_set_k(from._internal_k());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SampleTopKRequest::CopyFrom(const SampleTopKRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.SampleTopKRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SampleTopKRequest::IsInitialized() const {
  return true;
}

void SampleTopKRequest::InternalSwap(SampleTopKRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SampleTopKRequest, _impl_.k_)
      + sizeof(SampleTopKRequest::_impl_.k_)
      - PROTOBUF_FIELD_OFFSET(SampleTopKRequest, _impl_.distribution_id_)>(
          reinterpret_cast<char*>(&_impl_.distribution_id_),
          reinterpret_cast<char*>(&other->_impl_.distribution_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SampleTopKRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[14]);
}
// ===================================================================

class BatchSampleTopKRequest::_Internal {
 public:
};

BatchSampleTopKRequest::BatchSampleTopKRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchSampleTopKRequest)
}
BatchSampleTopKRequest::BatchSampleTopKRequest(const BatchSampleTopKRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchSampleTopKRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchSampleTopKRequest)
}

inline void BatchSampleTopKRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchSampleTopKRequest::~BatchSampleTopKRequest() {
  // @@protoc_insertion_point(destructor:l4m.BatchSampleTopKRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchSampleTopKRequest::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchSampleTopKRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchSampleTopKRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchSampleTopKRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchSampleTopKRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.SampleTopKRequest items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchSampleTopKRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchSampleTopKRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.SampleTopKRequest items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchSampleTopKRequest)
  return target;
}

::size_t BatchSampleTopKRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchSampleTopKRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.SampleTopKRequest items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchSampleTopKRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchSampleTopKRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchSampleTopKRequest::GetClassData() const { return &_class_data_; }


void BatchSampleTopKRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchSampleTopKRequest*>(&to_msg);
  auto& from = static_cast<const BatchSampleTopKRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchSampleTopKRequest)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchSampleTopKRequest::CopyFrom(const BatchSampleTopKRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchSampleTopKRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchSampleTopKRequest::IsInitialized() const {
  return true;
}

void BatchSampleTopKRequest::InternalSwap(BatchSampleTopKRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchSampleTopKRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[15]);
}
// ===================================================================

class SampleTopKResponse::_Internal {
 public:
};

SampleTopKResponse::SampleTopKResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.SampleTopKResponse)
}
SampleTopKResponse::SampleTopKResponse(const SampleTopKResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SampleTopKResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.token_ids_) { from._impl_.token_ids_ }
    ,/* _impl_._token_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.probabilities_) { from._impl_.probabilities_ }

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.SampleTopKResponse)
}

inline void SampleTopKResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.token_ids_) { arena }
    ,/* _impl_._token_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.probabilities_) { arena }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SampleTopKResponse::~SampleTopKResponse() {
  // @@protoc_insertion_point(destructor:l4m.SampleTopKResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SampleTopKResponse::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_ids_.~RepeatedField();
  _impl_.probabilities_.~RepeatedField();
}

void SampleTopKResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SampleTopKResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.SampleTopKResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.token_ids_.Clear();
  _impl_.probabilities_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SampleTopKResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 token_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_token_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 8) {
          _internal_add_token_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float probabilities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_probabilities(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 21) {
          _internal_add_probabilities(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SampleTopKResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.SampleTopKResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 token_ids = 1;
  {
    int byte_size = _impl_._token_ids_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(1, _internal_token_ids(),
                                                 byte_size, target);
    }
  }

  // repeated float probabilities = 2;
  if (this->_internal_probabilities_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_probabilities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.SampleTopKResponse)
  return target;
}

::size_t SampleTopKResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.SampleTopKResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 token_ids = 1;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.token_ids_)
    ;
    _impl_._token_ids_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated float probabilities = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_probabilities_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SampleTopKResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SampleTopKResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SampleTopKResponse::GetClassData() const { return &_class_data_; }


void SampleTopKResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SampleTopKResponse*>(&to_msg);
  auto& from = static_cast<const SampleTopKResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.SampleTopKResponse)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.token_ids_.MergeFrom(from._impl_.token_ids_);
  _this->_impl_.probabilities_.MergeFrom(from._impl_.probabilities_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SampleTopKResponse::CopyFrom(const SampleTopKResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.SampleTopKResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SampleTopKResponse::IsInitialized() const {
  return true;
}

void SampleTopKResponse::InternalSwap(SampleTopKResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.token_ids_.InternalSwap(&other->_impl_.token_ids_);
  _impl_.probabilities_.InternalSwap(&other->_impl_.probabilities_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SampleTopKResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[16]);
}
// ===================================================================

class BatchSampleTopKResponse::_Internal {
 public:
};

BatchSampleTopKResponse::BatchSampleTopKResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.BatchSampleTopKResponse)
}
BatchSampleTopKResponse::BatchSampleTopKResponse(const BatchSampleTopKResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchSampleTopKResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.BatchSampleTopKResponse)
}

inline void BatchSampleTopKResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchSampleTopKResponse::~BatchSampleTopKResponse() {
  // @@protoc_insertion_point(destructor:l4m.BatchSampleTopKResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchSampleTopKResponse::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BatchSampleTopKResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchSampleTopKResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.BatchSampleTopKResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchSampleTopKResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .l4m.SampleTopKResponse items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchSampleTopKResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.BatchSampleTopKResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .l4m.SampleTopKResponse items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.BatchSampleTopKResponse)
  return target;
}

::size_t BatchSampleTopKResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.BatchSampleTopKResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .l4m.SampleTopKResponse items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchSampleTopKResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchSampleTopKResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchSampleTopKResponse::GetClassData() const { return &_class_data_; }


void BatchSampleTopKResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchSampleTopKResponse*>(&to_msg);
  auto& from = static_cast<const BatchSampleTopKResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.BatchSampleTopKResponse)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchSampleTopKResponse::CopyFrom(const BatchSampleTopKResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.BatchSampleTopKResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchSampleTopKResponse::IsInitialized() const {
  return true;
}

void BatchSampleTopKResponse::InternalSwap(BatchSampleTopKResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchSampleTopKResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[17]);
}
// ===================================================================

class GetInfoRequest::_Internal {
 public:
};

GetInfoRequest::GetInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:l4m.GetInfoRequest)
}
GetInfoRequest::GetInfoRequest(const GetInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GetInfoRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:l4m.GetInfoRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetInfoRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GetInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[18]);
}
// ===================================================================

class GetInfoResponse::_Internal {
 public:
};

GetInfoResponse::GetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.GetInfoResponse)
}
GetInfoResponse::GetInfoResponse(const GetInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.block_size_) {}

    , decltype(_impl_.num_available_blocks_) {}

    , decltype(_impl_.num_available_embeddings_) {}

    , decltype(_impl_.num_available_distributions_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_name().empty()) {
    _this->_impl_.model_name_.Set(from._internal_model_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.block_size_, &from._impl_.block_size_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.num_available_distributions_) -
    reinterpret_cast<char*>(&_impl_.block_size_)) + sizeof(_impl_.num_available_distributions_));
  // @@protoc_insertion_point(copy_constructor:l4m.GetInfoResponse)
}

inline void GetInfoResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.block_size_) { 0u }

    , decltype(_impl_.num_available_blocks_) { 0u }

    , decltype(_impl_.num_available_embeddings_) { 0u }

    , decltype(_impl_.num_available_distributions_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetInfoResponse::~GetInfoResponse() {
  // @@protoc_insertion_point(destructor:l4m.GetInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetInfoResponse::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
  _impl_.model_name_.Destroy();
}

void GetInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.GetInfoResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.ClearToEmpty();
  _impl_.model_name_.ClearToEmpty();
  ::memset(&_impl_.block_size_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.num_available_distributions_) -
      reinterpret_cast<char*>(&_impl_.block_size_)) + sizeof(_impl_.num_available_distributions_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "l4m.GetInfoResponse.version"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string model_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "l4m.GetInfoResponse.model_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 block_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 num_available_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.num_available_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 num_available_embeddings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.num_available_embeddings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 num_available_distributions = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.num_available_distributions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GetInfoResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.GetInfoResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string version = 1;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "l4m.GetInfoResponse.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // string model_name = 2;
  if (!this->_internal_model_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "l4m.GetInfoResponse.model_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model_name(), target);
  }

  // uint32 block_size = 3;
  if (this->_internal_block_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_block_size(), target);
  }

  // uint32 num_available_blocks = 4;
  if (this->_internal_num_available_blocks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_num_available_blocks(), target);
  }

  // uint32 num_available_embeddings = 5;
  if (this->_internal_num_available_embeddings() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_num_available_embeddings(), target);
  }

  // uint32 num_available_distributions = 6;
  if (this->_internal_num_available_distributions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_num_available_distributions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.GetInfoResponse)
  return target;
}

::size_t GetInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.GetInfoResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string version = 1;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string model_name = 2;
  if (!this->_internal_model_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  // uint32 block_size = 3;
  if (this->_internal_block_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_block_size());
  }

  // uint32 num_available_blocks = 4;
  if (this->_internal_num_available_blocks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_num_available_blocks());
  }

  // uint32 num_available_embeddings = 5;
  if (this->_internal_num_available_embeddings() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_num_available_embeddings());
  }

  // uint32 num_available_distributions = 6;
  if (this->_internal_num_available_distributions() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_num_available_distributions());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetInfoResponse::GetClassData() const { return &_class_data_; }


void GetInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetInfoResponse*>(&to_msg);
  auto& from = static_cast<const GetInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.GetInfoResponse)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_model_name().empty()) {
    _this->_internal_set_model_name(from._internal_model_name());
  }
  if (from._internal_block_size() != 0) {
    _this->_internal_set_block_size(from._internal_block_size());
  }
  if (from._internal_num_available_blocks() != 0) {
    _this->_internal_set_num_available_blocks(from._internal_num_available_blocks());
  }
  if (from._internal_num_available_embeddings() != 0) {
    _this->_internal_set_num_available_embeddings(from._internal_num_available_embeddings());
  }
  if (from._internal_num_available_distributions() != 0) {
    _this->_internal_set_num_available_distributions(from._internal_num_available_distributions());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetInfoResponse::CopyFrom(const GetInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.GetInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetInfoResponse::IsInitialized() const {
  return true;
}

void GetInfoResponse::InternalSwap(GetInfoResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_name_, lhs_arena,
      &other->_impl_.model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetInfoResponse, _impl_.num_available_distributions_)
      + sizeof(GetInfoResponse::_impl_.num_available_distributions_)
      - PROTOBUF_FIELD_OFFSET(GetInfoResponse, _impl_.block_size_)>(
          reinterpret_cast<char*>(&_impl_.block_size_),
          reinterpret_cast<char*>(&other->_impl_.block_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[19]);
}
// ===================================================================

class Request::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::l4m::Request, _impl_._oneof_case_);
  static const ::l4m::BatchAllocate& allocate(const Request* msg);
  static const ::l4m::BatchDeallocate& deallocate(const Request* msg);
  static const ::l4m::BatchEmbedText& embed_text(const Request* msg);
  static const ::l4m::BatchFillBlock& fill_block(const Request* msg);
  static const ::l4m::BatchMaskBlock& mask_block(const Request* msg);
  static const ::l4m::BatchCopyBlock& copy_block(const Request* msg);
  static const ::l4m::BatchDecodeTokenDistribution& decode_token_distribution(const Request* msg);
  static const ::l4m::BatchSampleTopKRequest& sample_top_k_request(const Request* msg);
  static const ::l4m::GetInfoRequest& get_info(const Request* msg);
};

const ::l4m::BatchAllocate&
Request::_Internal::allocate(const Request* msg) {
  return *msg->_impl_.command_.allocate_;
}
const ::l4m::BatchDeallocate&
Request::_Internal::deallocate(const Request* msg) {
  return *msg->_impl_.command_.deallocate_;
}
const ::l4m::BatchEmbedText&
Request::_Internal::embed_text(const Request* msg) {
  return *msg->_impl_.command_.embed_text_;
}
const ::l4m::BatchFillBlock&
Request::_Internal::fill_block(const Request* msg) {
  return *msg->_impl_.command_.fill_block_;
}
const ::l4m::BatchMaskBlock&
Request::_Internal::mask_block(const Request* msg) {
  return *msg->_impl_.command_.mask_block_;
}
const ::l4m::BatchCopyBlock&
Request::_Internal::copy_block(const Request* msg) {
  return *msg->_impl_.command_.copy_block_;
}
const ::l4m::BatchDecodeTokenDistribution&
Request::_Internal::decode_token_distribution(const Request* msg) {
  return *msg->_impl_.command_.decode_token_distribution_;
}
const ::l4m::BatchSampleTopKRequest&
Request::_Internal::sample_top_k_request(const Request* msg) {
  return *msg->_impl_.command_.sample_top_k_request_;
}
const ::l4m::GetInfoRequest&
Request::_Internal::get_info(const Request* msg) {
  return *msg->_impl_.command_.get_info_;
}
void Request::set_allocated_allocate(::l4m::BatchAllocate* allocate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (allocate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allocate);
    if (message_arena != submessage_arena) {
      allocate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allocate, submessage_arena);
    }
    set_has_allocate();
    _impl_.command_.allocate_ = allocate;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.allocate)
}
void Request::set_allocated_deallocate(::l4m::BatchDeallocate* deallocate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (deallocate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deallocate);
    if (message_arena != submessage_arena) {
      deallocate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deallocate, submessage_arena);
    }
    set_has_deallocate();
    _impl_.command_.deallocate_ = deallocate;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.deallocate)
}
void Request::set_allocated_embed_text(::l4m::BatchEmbedText* embed_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (embed_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(embed_text);
    if (message_arena != submessage_arena) {
      embed_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embed_text, submessage_arena);
    }
    set_has_embed_text();
    _impl_.command_.embed_text_ = embed_text;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.embed_text)
}
void Request::set_allocated_fill_block(::l4m::BatchFillBlock* fill_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (fill_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fill_block);
    if (message_arena != submessage_arena) {
      fill_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill_block, submessage_arena);
    }
    set_has_fill_block();
    _impl_.command_.fill_block_ = fill_block;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.fill_block)
}
void Request::set_allocated_mask_block(::l4m::BatchMaskBlock* mask_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (mask_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mask_block);
    if (message_arena != submessage_arena) {
      mask_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask_block, submessage_arena);
    }
    set_has_mask_block();
    _impl_.command_.mask_block_ = mask_block;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.mask_block)
}
void Request::set_allocated_copy_block(::l4m::BatchCopyBlock* copy_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (copy_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(copy_block);
    if (message_arena != submessage_arena) {
      copy_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, copy_block, submessage_arena);
    }
    set_has_copy_block();
    _impl_.command_.copy_block_ = copy_block;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.copy_block)
}
void Request::set_allocated_decode_token_distribution(::l4m::BatchDecodeTokenDistribution* decode_token_distribution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (decode_token_distribution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decode_token_distribution);
    if (message_arena != submessage_arena) {
      decode_token_distribution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decode_token_distribution, submessage_arena);
    }
    set_has_decode_token_distribution();
    _impl_.command_.decode_token_distribution_ = decode_token_distribution;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.decode_token_distribution)
}
void Request::set_allocated_sample_top_k_request(::l4m::BatchSampleTopKRequest* sample_top_k_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (sample_top_k_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sample_top_k_request);
    if (message_arena != submessage_arena) {
      sample_top_k_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sample_top_k_request, submessage_arena);
    }
    set_has_sample_top_k_request();
    _impl_.command_.sample_top_k_request_ = sample_top_k_request;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.sample_top_k_request)
}
void Request::set_allocated_get_info(::l4m::GetInfoRequest* get_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (get_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_info);
    if (message_arena != submessage_arena) {
      get_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_info, submessage_arena);
    }
    set_has_get_info();
    _impl_.command_.get_info_ = get_info;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Request.get_info)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_) {}

    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.correlation_id_ = from._impl_.correlation_id_;
  clear_has_command();
  switch (from.command_case()) {
    case kAllocate: {
      _this->_internal_mutable_allocate()->::l4m::BatchAllocate::MergeFrom(
          from._internal_allocate());
      break;
    }
    case kDeallocate: {
      _this->_internal_mutable_deallocate()->::l4m::BatchDeallocate::MergeFrom(
          from._internal_deallocate());
      break;
    }
    case kEmbedText: {
      _this->_internal_mutable_embed_text()->::l4m::BatchEmbedText::MergeFrom(
          from._internal_embed_text());
      break;
    }
    case kFillBlock: {
      _this->_internal_mutable_fill_block()->::l4m::BatchFillBlock::MergeFrom(
          from._internal_fill_block());
      break;
    }
    case kMaskBlock: {
      _this->_internal_mutable_mask_block()->::l4m::BatchMaskBlock::MergeFrom(
          from._internal_mask_block());
      break;
    }
    case kCopyBlock: {
      _this->_internal_mutable_copy_block()->::l4m::BatchCopyBlock::MergeFrom(
          from._internal_copy_block());
      break;
    }
    case kDecodeTokenDistribution: {
      _this->_internal_mutable_decode_token_distribution()->::l4m::BatchDecodeTokenDistribution::MergeFrom(
          from._internal_decode_token_distribution());
      break;
    }
    case kSampleTopKRequest: {
      _this->_internal_mutable_sample_top_k_request()->::l4m::BatchSampleTopKRequest::MergeFrom(
          from._internal_sample_top_k_request());
      break;
    }
    case kGetInfo: {
      _this->_internal_mutable_get_info()->::l4m::GetInfoRequest::MergeFrom(
          from._internal_get_info());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:l4m.Request)
}

inline void Request::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_) { 0u }

    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_command();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:l4m.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:l4m.Request)
  switch (command_case()) {
    case kAllocate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.allocate_;
      }
      break;
    }
    case kDeallocate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.deallocate_;
      }
      break;
    }
    case kEmbedText: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.embed_text_;
      }
      break;
    }
    case kFillBlock: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.fill_block_;
      }
      break;
    }
    case kMaskBlock: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.mask_block_;
      }
      break;
    }
    case kCopyBlock: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.copy_block_;
      }
      break;
    }
    case kDecodeTokenDistribution: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.decode_token_distribution_;
      }
      break;
    }
    case kSampleTopKRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.sample_top_k_request_;
      }
      break;
    }
    case kGetInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.get_info_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.Request)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.correlation_id_ = 0u;
  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 correlation_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.correlation_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchAllocate allocate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_allocate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchDeallocate deallocate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_deallocate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchEmbedText embed_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_embed_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchFillBlock fill_block = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchMaskBlock mask_block = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mask_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchCopyBlock copy_block = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_copy_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchDecodeTokenDistribution decode_token_distribution = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_decode_token_distribution(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchSampleTopKRequest sample_top_k_request = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_sample_top_k_request(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.GetInfoRequest get_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Request::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.Request)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 correlation_id = 1;
  if (this->_internal_correlation_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_correlation_id(), target);
  }

  // .l4m.BatchAllocate allocate = 2;
  if (command_case() == kAllocate) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::allocate(this),
        _Internal::allocate(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchDeallocate deallocate = 3;
  if (command_case() == kDeallocate) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::deallocate(this),
        _Internal::deallocate(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchEmbedText embed_text = 4;
  if (command_case() == kEmbedText) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::embed_text(this),
        _Internal::embed_text(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchFillBlock fill_block = 5;
  if (command_case() == kFillBlock) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::fill_block(this),
        _Internal::fill_block(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchMaskBlock mask_block = 6;
  if (command_case() == kMaskBlock) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::mask_block(this),
        _Internal::mask_block(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchCopyBlock copy_block = 7;
  if (command_case() == kCopyBlock) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::copy_block(this),
        _Internal::copy_block(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchDecodeTokenDistribution decode_token_distribution = 8;
  if (command_case() == kDecodeTokenDistribution) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::decode_token_distribution(this),
        _Internal::decode_token_distribution(this).GetCachedSize(), target, stream);
  }

  // .l4m.BatchSampleTopKRequest sample_top_k_request = 9;
  if (command_case() == kSampleTopKRequest) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::sample_top_k_request(this),
        _Internal::sample_top_k_request(this).GetCachedSize(), target, stream);
  }

  // .l4m.GetInfoRequest get_info = 10;
  if (command_case() == kGetInfo) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::get_info(this),
        _Internal::get_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.Request)
  return target;
}

::size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.Request)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 correlation_id = 1;
  if (this->_internal_correlation_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_correlation_id());
  }

  switch (command_case()) {
    // .l4m.BatchAllocate allocate = 2;
    case kAllocate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.allocate_);
      break;
    }
    // .l4m.BatchDeallocate deallocate = 3;
    case kDeallocate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.deallocate_);
      break;
    }
    // .l4m.BatchEmbedText embed_text = 4;
    case kEmbedText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.embed_text_);
      break;
    }
    // .l4m.BatchFillBlock fill_block = 5;
    case kFillBlock: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.fill_block_);
      break;
    }
    // .l4m.BatchMaskBlock mask_block = 6;
    case kMaskBlock: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.mask_block_);
      break;
    }
    // .l4m.BatchCopyBlock copy_block = 7;
    case kCopyBlock: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.copy_block_);
      break;
    }
    // .l4m.BatchDecodeTokenDistribution decode_token_distribution = 8;
    case kDecodeTokenDistribution: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.decode_token_distribution_);
      break;
    }
    // .l4m.BatchSampleTopKRequest sample_top_k_request = 9;
    case kSampleTopKRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.sample_top_k_request_);
      break;
    }
    // .l4m.GetInfoRequest get_info = 10;
    case kGetInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.get_info_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.Request)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_correlation_id() != 0) {
    _this->_internal_set_correlation_id(from._internal_correlation_id());
  }
  switch (from.command_case()) {
    case kAllocate: {
      _this->_internal_mutable_allocate()->::l4m::BatchAllocate::MergeFrom(
          from._internal_allocate());
      break;
    }
    case kDeallocate: {
      _this->_internal_mutable_deallocate()->::l4m::BatchDeallocate::MergeFrom(
          from._internal_deallocate());
      break;
    }
    case kEmbedText: {
      _this->_internal_mutable_embed_text()->::l4m::BatchEmbedText::MergeFrom(
          from._internal_embed_text());
      break;
    }
    case kFillBlock: {
      _this->_internal_mutable_fill_block()->::l4m::BatchFillBlock::MergeFrom(
          from._internal_fill_block());
      break;
    }
    case kMaskBlock: {
      _this->_internal_mutable_mask_block()->::l4m::BatchMaskBlock::MergeFrom(
          from._internal_mask_block());
      break;
    }
    case kCopyBlock: {
      _this->_internal_mutable_copy_block()->::l4m::BatchCopyBlock::MergeFrom(
          from._internal_copy_block());
      break;
    }
    case kDecodeTokenDistribution: {
      _this->_internal_mutable_decode_token_distribution()->::l4m::BatchDecodeTokenDistribution::MergeFrom(
          from._internal_decode_token_distribution());
      break;
    }
    case kSampleTopKRequest: {
      _this->_internal_mutable_sample_top_k_request()->::l4m::BatchSampleTopKRequest::MergeFrom(
          from._internal_sample_top_k_request());
      break;
    }
    case kGetInfo: {
      _this->_internal_mutable_get_info()->::l4m::GetInfoRequest::MergeFrom(
          from._internal_get_info());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.correlation_id_, other->_impl_.correlation_id_);
  swap(_impl_.command_, other->_impl_.command_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[20]);
}
// ===================================================================

class Response::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::l4m::Response, _impl_._oneof_case_);
  static const ::l4m::BatchSampleTopKResponse& sample_top_k(const Response* msg);
  static const ::l4m::GetInfoResponse& get_info(const Response* msg);
};

const ::l4m::BatchSampleTopKResponse&
Response::_Internal::sample_top_k(const Response* msg) {
  return *msg->_impl_.command_.sample_top_k_;
}
const ::l4m::GetInfoResponse&
Response::_Internal::get_info(const Response* msg) {
  return *msg->_impl_.command_.get_info_;
}
void Response::set_allocated_sample_top_k(::l4m::BatchSampleTopKResponse* sample_top_k) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (sample_top_k) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sample_top_k);
    if (message_arena != submessage_arena) {
      sample_top_k = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sample_top_k, submessage_arena);
    }
    set_has_sample_top_k();
    _impl_.command_.sample_top_k_ = sample_top_k;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Response.sample_top_k)
}
void Response::set_allocated_get_info(::l4m::GetInfoResponse* get_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (get_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_info);
    if (message_arena != submessage_arena) {
      get_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_info, submessage_arena);
    }
    set_has_get_info();
    _impl_.command_.get_info_ = get_info;
  }
  // @@protoc_insertion_point(field_set_allocated:l4m.Response.get_info)
}
Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:l4m.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_) {}

    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.correlation_id_ = from._impl_.correlation_id_;
  clear_has_command();
  switch (from.command_case()) {
    case kSampleTopK: {
      _this->_internal_mutable_sample_top_k()->::l4m::BatchSampleTopKResponse::MergeFrom(
          from._internal_sample_top_k());
      break;
    }
    case kGetInfo: {
      _this->_internal_mutable_get_info()->::l4m::GetInfoResponse::MergeFrom(
          from._internal_get_info());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:l4m.Response)
}

inline void Response::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_) { 0u }

    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_command();
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:l4m.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:l4m.Response)
  switch (command_case()) {
    case kSampleTopK: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.sample_top_k_;
      }
      break;
    }
    case kGetInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.command_.get_info_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:l4m.Response)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.correlation_id_ = 0u;
  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 correlation_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.correlation_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.BatchSampleTopKResponse sample_top_k = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sample_top_k(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .l4m.GetInfoResponse get_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Response::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:l4m.Response)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 correlation_id = 1;
  if (this->_internal_correlation_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_correlation_id(), target);
  }

  // .l4m.BatchSampleTopKResponse sample_top_k = 2;
  if (command_case() == kSampleTopK) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sample_top_k(this),
        _Internal::sample_top_k(this).GetCachedSize(), target, stream);
  }

  // .l4m.GetInfoResponse get_info = 3;
  if (command_case() == kGetInfo) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::get_info(this),
        _Internal::get_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:l4m.Response)
  return target;
}

::size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:l4m.Response)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 correlation_id = 1;
  if (this->_internal_correlation_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_correlation_id());
  }

  switch (command_case()) {
    // .l4m.BatchSampleTopKResponse sample_top_k = 2;
    case kSampleTopK: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.sample_top_k_);
      break;
    }
    // .l4m.GetInfoResponse get_info = 3;
    case kGetInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_.get_info_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:l4m.Response)
  GOOGLE_ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_correlation_id() != 0) {
    _this->_internal_set_correlation_id(from._internal_correlation_id());
  }
  switch (from.command_case()) {
    case kSampleTopK: {
      _this->_internal_mutable_sample_top_k()->::l4m::BatchSampleTopKResponse::MergeFrom(
          from._internal_sample_top_k());
      break;
    }
    case kGetInfo: {
      _this->_internal_mutable_get_info()->::l4m::GetInfoResponse::MergeFrom(
          from._internal_get_info());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:l4m.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.correlation_id_, other->_impl_.correlation_id_);
  swap(_impl_.command_, other->_impl_.command_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l4m_2eproto_getter, &descriptor_table_l4m_2eproto_once,
      file_level_metadata_l4m_2eproto[21]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace l4m
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::l4m::Allocate*
Arena::CreateMaybeMessage< ::l4m::Allocate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::Allocate >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchAllocate*
Arena::CreateMaybeMessage< ::l4m::BatchAllocate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchAllocate >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::Deallocate*
Arena::CreateMaybeMessage< ::l4m::Deallocate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::Deallocate >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchDeallocate*
Arena::CreateMaybeMessage< ::l4m::BatchDeallocate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchDeallocate >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::EmbedText*
Arena::CreateMaybeMessage< ::l4m::EmbedText >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::EmbedText >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchEmbedText*
Arena::CreateMaybeMessage< ::l4m::BatchEmbedText >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchEmbedText >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::FillBlock*
Arena::CreateMaybeMessage< ::l4m::FillBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::FillBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchFillBlock*
Arena::CreateMaybeMessage< ::l4m::BatchFillBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchFillBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::MaskBlock*
Arena::CreateMaybeMessage< ::l4m::MaskBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::MaskBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchMaskBlock*
Arena::CreateMaybeMessage< ::l4m::BatchMaskBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchMaskBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::CopyBlock*
Arena::CreateMaybeMessage< ::l4m::CopyBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::CopyBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchCopyBlock*
Arena::CreateMaybeMessage< ::l4m::BatchCopyBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchCopyBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::DecodeTokenDistribution*
Arena::CreateMaybeMessage< ::l4m::DecodeTokenDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::DecodeTokenDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchDecodeTokenDistribution*
Arena::CreateMaybeMessage< ::l4m::BatchDecodeTokenDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchDecodeTokenDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::SampleTopKRequest*
Arena::CreateMaybeMessage< ::l4m::SampleTopKRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::SampleTopKRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchSampleTopKRequest*
Arena::CreateMaybeMessage< ::l4m::BatchSampleTopKRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchSampleTopKRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::SampleTopKResponse*
Arena::CreateMaybeMessage< ::l4m::SampleTopKResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::SampleTopKResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::BatchSampleTopKResponse*
Arena::CreateMaybeMessage< ::l4m::BatchSampleTopKResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::BatchSampleTopKResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::GetInfoRequest*
Arena::CreateMaybeMessage< ::l4m::GetInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::GetInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::GetInfoResponse*
Arena::CreateMaybeMessage< ::l4m::GetInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::GetInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::Request*
Arena::CreateMaybeMessage< ::l4m::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::l4m::Response*
Arena::CreateMaybeMessage< ::l4m::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::l4m::Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
