# build.ninja for CUDA C++ Project with FlashInfer and cppzmq

# Variables
nvcc = nvcc
cxxflags = -std=c++20 -Xcompiler -Wall -Xcompiler -Wextra -gencode arch=compute_89,code=sm_89 --extended-lambda
# Add -g -G for debug symbols and device-side debugging
# cxxflags += -g -G

src_dir = src
include_dir = include
lib_dir = lib
build_dir = build
bin_dir = bin

flashinfer_include_dir = $lib_dir/flashinfer/include
# Add cppzmq include path. Since cppzmq headers are in its root, the path is just the submodule directory.
cppzmq_include_dir = $lib_dir/cppzmq

# Updated include paths
inc_path = -I$include_dir -I$flashinfer_include_dir -I$cppzmq_include_dir

# Rules

# Rule to compile CUDA .cu files into object files
rule cu_compile
  command = $nvcc $cxxflags $inc_path -c $in -o $out
  description = Compiling $in

# Rule to link object files into the final executable
rule link
  command = $nvcc $cxxflags $in -o $out -lcublas -lcublasLt -lyaml-cpp
  description = Linking $out

# Build edges

# Object files
build $build_dir/l4ma.o: cu_compile $src_dir/l4ma.cu
build $build_dir/main.o: cu_compile $src_dir/main.cu

# Executable
build $bin_dir/cuda_app: link $build_dir/main.o $build_dir/l4ma.o

# Default target: builds the executable
default $bin_dir/cuda_app
build all: phony $bin_dir/cuda_app

# Clean up build artifacts
rule clean
  command = rm -rf $build_dir $bin_dir $lib_dir/cppzmq # Optionally clean the submodule too if desired, or manage manually
  description = Cleaning build artifacts
build clean: clean

# Phony target for running the application
build run: phony $bin_dir/cuda_app
