// Interface for l4m module
interface l4m {

    // Import pollable functionality from the WASI IO poll package
    use wasi:io/poll@0.2.4.{pollable};

    // Define basic types
    type object-id = u32;   // Object identifier type (unsigned 32-bit integer)
    type stream-id = u32;   // stream-id identifier type (unsigned 32-bit integer)

    // Enumeration for different object types
    enum object-type {
        block,  // Block object
        embed,  // Embed object
        dist,   // Distribution object
    }

    enum stream-priority {
        low,
        normal, // Default
        high,
    }

    // Function to retrieve a model by its name; returns an optional model
    get-model: func(name:string) -> option<model>;

    // Function to retrieve a list of all model names
    get-all-models: func() -> list<string>;

    resource model {
        // Returns the block size as a 32-bit unsigned integer
        get-block-size: func() -> u32;

        // Get model tokenizer
        get-tokenizer: func() -> tokenizer;

        // Retrieves a list of all adapter names
        get-all-adapters: func() -> list<string>;

        // Retrieves all exported blocks as a list of (name, size) tuples
        get-all-exported-blocks: func() -> list<tuple<string, u32>>;

        // Allocates objects in a given stream-id, for a specified type and a list of object IDs
        // Deallocates objects from a given stream-id, for a specified type and a list of object IDs
        allocate: func(stream-id: stream-id, ty: object-type, object-ids: list<object-id>);
        deallocate: func(stream-id: stream-id, ty: object-type, object-ids: list<object-id>);

        // Fills a block with data based on context block IDs, input embed IDs, and output embed IDs
        // Fills a block using a specific adapter along with context block IDs and embed IDs for input/output
        fill-block: func(stream-id: stream-id, block-id: object-id, context-block-ids: list<object-id>, input-emb-ids: list<object-id>, output-emb-ids: list<object-id>);
        fill-block-with-adapter: func(stream-id: stream-id, adapter: string, block-id: object-id, context-block-ids: list<object-id>, input-emb-ids: list<object-id>, output-emb-ids: list<object-id>);

        // Copies data from a source block to a destination block with specified offsets and size
        copy-block: func(stream-id: stream-id, src-block-id: object-id, dst-block-id: object-id, src-offset: u32, dst-offset: u32, size: u32);

        // Applies a mask to a block using a list of unsigned 32-bit integers
        mask-block: func(stream-id: stream-id, block-id: object-id, mask: list<bool>);

        // Exports a list of source block IDs under a given name
        // Imports blocks into the destination list using a given name
        export-blocks: func(src-block-ids: list<object-id>, name: string);
        import-blocks: func(dst-block-ids: list<object-id>, name: string);

        // Embeds text into the model using embed IDs, tokens, and their positions
        embed-text: func(stream-id: stream-id, emb-ids: list<object-id>, tokens: list<u32>, positions: list<u32>);

        // Decodes the token distribution using embed IDs and distribution IDs
        decode-token-dist: func(stream-id: stream-id, emb-ids: list<object-id>, dist-ids: list<object-id>);

        // Samples the top k elements from a token distribution; returns a sample-top-k-result resource
        sample-top-k: func(stream-id: stream-id, dist-ids: list<object-id>, k: u32) -> sample-top-k-result;

        // Wait for the stream
        synchronize: func(stream-id: stream-id) -> synchronization-result;

        // Set stream priority
        set-stream-priority: func(stream-id: stream-id, priority: stream-priority);

    }

    resource tokenizer {
        // Tokenizes a given text into a list of token IDs
        tokenize: func(text: string) -> list<u32>;

        // Converts a list of token IDs back into a string
        detokenize: func(tokens: list<u32>) -> string;

        // Retrieves the vocabulary as a list of lists of bytes
        get-vocabs: func() -> list<list<u8>>;
    }

    // Resource representing the result of the sample-top-k function
    resource sample-top-k-result {
        // Subscribes to the sample result, returning a pollable object
        subscribe: func() -> pollable;

        // Retrieves the sample result as an optional list of tuples; returns None if not ready
        get: func() -> option<list<tuple<list<u32>, list<f32>>>>; // None if not ready
    }

    resource synchronization-result {
        subscribe: func() -> pollable;
        get: func() -> option<bool>; // None if not ready
    }
}