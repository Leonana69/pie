interface kvcache {

  flags mask {
    causal,
    empty,
    // more flags will be added later, e.g., windowed, etc.
  }

  flags sink {
    fill, // fill all missing slots starting from the beginning
    fill-last, // start filling from the last empty block.
    new-block, // always sink into a new block
  }

  variant position-ids {
     u32, // position offset
     list<u32>, // list of position offsets
  }


  //

  resource embedding {

  }
  resource embedding-list {

  }

  embed-tokens: func(tokens: list<u32>, positions: list<u32>) -> embedding-list;
  embed-string: func(text: string, position_offset: u32) -> embedding-list;
  embed-image: func(url: string, position_offset: u32) -> embedding-list;
  embed-sound: func(url: string, position_offset: u32) -> embedding-list;

  resource block {
     // keeps block_id internally.
     allocated: func() -> bool;
     drop: func(start: u32, end: u32);
     copy: func(other:block, src-start:u32, src-end:u32, dest-start: u32, dest-end: u32);
     fill: func(context:block-list, token-ids:list<u32>, position-ids:position-ids) -> dist;


}

  // this is actually a set. The order is just for indexing purposes. So this is more like a ranged map.
  // RLE-like encoding could be used to compress the list.
  // This is only needed to avoid WASM-host boundary crosssing.
  resource block-list {
    constructor(blocks: list<block>);
    length: func() -> u32;
    append: func(block: block);
    remove: func(block: block);
    extend: func(blocks: block-list);
    slice: func(start: u32, end: u32) -> block-list;
    index: func(position: u32) -> block;
  }


  // return "initialized" block handles (block id reserved after 2^18)
  allocate-block: func() -> block;
  allocate-blocks: func(count:u32) -> block-list;

  free-block: func(block: block);
  free-blocks: func(blocks: block-list);

  available-blocks: func() -> u32;

  //
  //
  // // a single cached token
  // resource token {
  //    position: func() -> u32;
  //    token-id: func() -> u32;
  // }
  //
  // // a sequence of cached tokens
  // resource token-list {
  //
  //   // the list could be empty
  //   constructor(tokens: list<token>);
  //
  //   // mutating methods
  //   push: func(token: token);
  //   pop: func() -> token;
  //   extend: func(tokens: token-list);
  //   splice: func(start: u32, delete-count: u32, tokens: token-list);
  //
  //   // non-mutating methods
  //   length: func() -> u32;
  //   slice: func(start: u32, end: u32) -> token-list;
  //   concat: func(cache: token-list) -> token-list;
  //   index: func(position: u32) -> token;
  //
  // }
}